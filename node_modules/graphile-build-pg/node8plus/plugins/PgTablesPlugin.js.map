{"version":3,"file":"PgTablesPlugin.js","names":["base64","str","Buffer","from","String","toString","hasNonNullKey","row","Array","isArray","__identifiers","every","i","k","Object","prototype","hasOwnProperty","call","PgTablesPlugin","builder","pgForbidSetofFunctionsToReturnNull","subscriptions","handleNullRow","_identifiers","identifiers","hook","_","build","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","newWithHooks","getSafeAliasFromResolveInfo","pgSql","sql","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pg2GqlMapper","gql2pg","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLID","GraphQLList","GraphQLInputObjectType","inflection","describePgEntity","sqlCommentByAddingTags","pgField","nullableIf","condition","Type","Cursor","class","forEach","table","tags","enum","tablePgType","type","Error","arrayTablePgType","arrayType","primaryKeyConstraint","primaryKeys","keyAttributes","attributes","tableTypeName","tableType","shouldHaveNodeId","isSelectable","namespace","length","TableType","TablePatchType","TableBaseInputType","id","cb","description","name","interfaces","builtin","fields","addDataGeneratorForField","Self","pgQuery","queryBuilder","selectIdentifiers","wrapDescription","resolve","data","finalIdentifiers","map","identifier","idx","key","domainBaseType","int","parseInt","Number","MAX_SAFE_INTEGER","__origin","pgIntrospection","isPgRowType","isPgCompoundType","isPgCompositeType","pgCreateInputFields","pgPatchInputFields","pgBaseInputFields","inputType","isInputType","pgAddSubfield","fieldName","attrName","pgType","spec","typeModifier","patchType","isPgPatch","baseInputType","isPgBaseInput","unmap","obj","modifier","fieldLookup","attr2sql","attr","column","inputField","v","fragment","isFake","namespaceName","null","join","EdgeType","edge","fieldWithHooks","cursor","addDataGenerator","usesCursor","__cursor","JSON","stringify","isCursorField","node","_args","resolveContext","resolveInfo","safeAlias","record","liveRecord","rootValue","withQueryBuilder","isEdgeType","isPgRowEdgeType","nodeType","PageInfo","connection","recurseDataGeneratorsForField","nodes","entry","edges","_context","hoistCursor","pageInfo","isConnectionType","isPgRowConnectionType","edgeType","_set","RelevantTableInputType","exports","default"],"sources":["../../src/plugins/PgTablesPlugin.js"],"sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nconst hasNonNullKey = row => {\n  if (\n    Array.isArray(row.__identifiers) &&\n    row.__identifiers.every(i => i != null)\n  ) {\n    return true;\n  }\n  for (const k in row) {\n    if (Object.prototype.hasOwnProperty.call(row, k)) {\n      if ((k[0] !== \"_\" || k[1] !== \"_\") && row[k] !== null) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nexport default (function PgTablesPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false, subscriptions = false }\n) {\n  const handleNullRow = pgForbidSetofFunctionsToReturnNull\n    ? (row, _identifiers) => row\n    : (row, identifiers) => {\n        if ((identifiers && hasNonNullKey(identifiers)) || hasNonNullKey(row)) {\n          return row;\n        } else {\n          return null;\n        }\n      };\n\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        getNodeIdForTypeAndIdentifiers,\n        nodeIdFieldName,\n        newWithHooks,\n        getSafeAliasFromResolveInfo,\n        pgSql: sql,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        pgRegisterGqlTypeByTypeId,\n        pgRegisterGqlInputTypeByTypeId,\n        pg2GqlMapper,\n        gql2pg,\n        graphql: {\n          GraphQLObjectType,\n          GraphQLNonNull,\n          GraphQLID,\n          GraphQLList,\n          GraphQLInputObjectType,\n        },\n        inflection,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n\n      const nullableIf = (condition, Type) =>\n        condition ? Type : new GraphQLNonNull(Type);\n      const Cursor = getTypeByName(\"Cursor\");\n\n      introspectionResultsByKind.class.forEach(table => {\n        if (table.tags.enum) {\n          return;\n        }\n        const tablePgType = table.type;\n        if (!tablePgType) {\n          throw new Error(\"Could not determine the type for this table\");\n        }\n        const arrayTablePgType = tablePgType.arrayType;\n        const primaryKeyConstraint = table.primaryKeyConstraint;\n        const primaryKeys =\n          primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n        const attributes = table.attributes;\n        const tableTypeName = inflection.tableType(table);\n        const shouldHaveNodeId: boolean =\n          nodeIdFieldName &&\n          table.isSelectable &&\n          table.namespace &&\n          primaryKeys &&\n          primaryKeys.length\n            ? true\n            : false;\n        let TableType;\n        let TablePatchType;\n        let TableBaseInputType;\n        pgRegisterGqlTypeByTypeId(\n          tablePgType.id,\n          cb => {\n            if (TableType) {\n              return TableType;\n            }\n            if (pg2GqlMapper[tablePgType.id]) {\n              // Already handled\n              throw new Error(\n                `Register was called but there's already a mapper in place for '${tablePgType.id}'!`\n              );\n            }\n            TableType = newWithHooks(\n              GraphQLObjectType,\n              {\n                description: table.description || tablePgType.description,\n                name: tableTypeName,\n                interfaces: () => {\n                  if (shouldHaveNodeId) {\n                    return [getTypeByName(inflection.builtin(\"Node\"))];\n                  } else {\n                    return [];\n                  }\n                },\n                fields: ({ addDataGeneratorForField, Self }) => {\n                  const fields = {};\n                  if (shouldHaveNodeId) {\n                    // Enable nodeId interface\n                    addDataGeneratorForField(nodeIdFieldName, () => {\n                      return {\n                        pgQuery: queryBuilder => {\n                          queryBuilder.selectIdentifiers(table);\n                        },\n                      };\n                    });\n                    fields[nodeIdFieldName] = {\n                      description: build.wrapDescription(\n                        \"A globally unique identifier. Can be used in various places throughout the system to identify this single value.\",\n                        \"field\"\n                      ),\n                      type: new GraphQLNonNull(GraphQLID),\n                      resolve(data) {\n                        const identifiers = data.__identifiers;\n                        if (!identifiers) {\n                          return null;\n                        }\n                        /*\n                         * For bigint we want NodeIDs to be the same as int up\n                         * to the limits of int, and only to be strings after\n                         * that point.\n                         */\n                        const finalIdentifiers = identifiers.map(\n                          (identifier, idx) => {\n                            const key = primaryKeys[idx];\n                            const type = key.type.domainBaseType || key.type;\n                            if (type.id === \"20\" /* bigint */) {\n                              /*\n                               * When migrating from 'int' to 'bigint' we want\n                               * to maintain nodeIDs in the safe range before\n                               * moving to strings for larger numbers. Since we\n                               * can represent ints up to MAX_SAFE_INTEGER\n                               * (2^53 - 1) fine, we're using that as the\n                               * boundary.\n                               */\n                              const int = parseInt(identifier, 10);\n                              if (\n                                int >= -Number.MAX_SAFE_INTEGER &&\n                                int <= Number.MAX_SAFE_INTEGER\n                              ) {\n                                return int;\n                              }\n                            }\n                            return identifier;\n                          }\n                        );\n                        return getNodeIdForTypeAndIdentifiers(\n                          Self,\n                          ...finalIdentifiers\n                        );\n                      },\n                    };\n                  }\n                  return fields;\n                },\n              },\n              {\n                __origin: `Adding table type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable, // TODO:v5: remove - typo\n                isPgCompositeType: !table.isSelectable,\n              }\n            );\n            cb(TableType);\n            const pgCreateInputFields = {};\n            const pgPatchInputFields = {};\n            const pgBaseInputFields = {};\n            newWithHooks(\n              GraphQLInputObjectType,\n              {\n                description: build.wrapDescription(\n                  `An input for mutations affecting \\`${tableTypeName}\\``,\n                  \"type\"\n                ),\n                name: inflection.inputType(TableType),\n              },\n              {\n                __origin: `Adding table input type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isInputType: true,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n                pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                  pgCreateInputFields[fieldName] = {\n                    name: attrName,\n                    type: pgType,\n                    typeModifier,\n                  };\n                  return spec;\n                },\n              },\n              true // If no fields, skip type automatically\n            );\n\n            if (table.isSelectable) {\n              // XXX: these don't belong here; but we have to keep them here\n              // because third-party code depends on `getTypeByName` to find\n              // them; so we have to register them ahead of time. A better\n              // approach is to use the modifier to specify the type you need,\n              // 'patch' or 'base', so they can be registered just in time.\n              TablePatchType = newWithHooks(\n                GraphQLInputObjectType,\n                {\n                  description: build.wrapDescription(\n                    `Represents an update to a \\`${tableTypeName}\\`. Fields that are set will be updated.`,\n                    \"type\"\n                  ),\n                  name: inflection.patchType(TableType),\n                },\n                {\n                  __origin: `Adding table patch type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  pgIntrospection: table,\n                  isPgRowType: table.isSelectable,\n                  isPgCompoundType: !table.isSelectable,\n                  isPgPatch: true,\n                  pgAddSubfield(\n                    fieldName,\n                    attrName,\n                    pgType,\n                    spec,\n                    typeModifier\n                  ) {\n                    pgPatchInputFields[fieldName] = {\n                      name: attrName,\n                      type: pgType,\n                      typeModifier,\n                    };\n                    return spec;\n                  },\n                },\n                true // Safe to skip this if no fields support updating\n              );\n              TableBaseInputType = newWithHooks(\n                GraphQLInputObjectType,\n                {\n                  description: build.wrapDescription(\n                    `An input representation of \\`${tableTypeName}\\` with nullable fields.`,\n                    \"type\"\n                  ),\n                  name: inflection.baseInputType(TableType),\n                },\n                {\n                  __origin: `Adding table base input type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  pgIntrospection: table,\n                  isPgRowType: table.isSelectable,\n                  isPgCompoundType: !table.isSelectable,\n                  isPgBaseInput: true,\n                  pgAddSubfield(\n                    fieldName,\n                    attrName,\n                    pgType,\n                    spec,\n                    typeModifier\n                  ) {\n                    pgBaseInputFields[fieldName] = {\n                      name: attrName,\n                      type: pgType,\n                      typeModifier,\n                    };\n                    return spec;\n                  },\n                }\n              );\n            }\n\n            pg2GqlMapper[tablePgType.id] = {\n              map: _ => _,\n              unmap: (obj, modifier) => {\n                let fieldLookup;\n                if (modifier === \"patch\") {\n                  fieldLookup = pgPatchInputFields;\n                } else if (modifier === \"base\") {\n                  fieldLookup = pgBaseInputFields;\n                } else {\n                  fieldLookup = pgCreateInputFields;\n                }\n\n                const attr2sql = attr => {\n                  // TODO: this should use `fieldInput[*].name` to find the attribute\n                  const fieldName = inflection.column(attr);\n                  const inputField = fieldLookup[fieldName];\n                  const v = obj[fieldName];\n                  if (inputField && v != null) {\n                    const { type, typeModifier } = inputField;\n                    return sql.fragment`${gql2pg(v, type, typeModifier)}::${\n                      type.isFake\n                        ? sql.identifier(\"unknown\")\n                        : sql.identifier(type.namespaceName, type.name)\n                    }`;\n                  } else {\n                    return sql.null; // TODO: return default instead.\n                  }\n                };\n\n                return sql.fragment`row(${sql.join(\n                  attributes.map(attr2sql),\n                  \",\"\n                )})::${\n                  tablePgType.isFake\n                    ? sql.identifier(\"unknown\")\n                    : sql.identifier(\n                        tablePgType.namespaceName,\n                        tablePgType.name\n                      )\n                }`;\n              },\n            };\n\n            const EdgeType = newWithHooks(\n              GraphQLObjectType,\n              {\n                description: build.wrapDescription(\n                  `A \\`${tableTypeName}\\` edge in the connection.`,\n                  \"type\"\n                ),\n                name: inflection.edge(TableType.name),\n                fields: ({ fieldWithHooks }) => {\n                  return {\n                    cursor: fieldWithHooks(\n                      \"cursor\",\n                      ({ addDataGenerator }) => {\n                        addDataGenerator(() => ({\n                          usesCursor: [true],\n                          pgQuery: queryBuilder => {\n                            if (primaryKeys) {\n                              queryBuilder.selectIdentifiers(table);\n                            }\n                          },\n                        }));\n                        return {\n                          description: build.wrapDescription(\n                            \"A cursor for use in pagination.\",\n                            \"field\"\n                          ),\n                          type: Cursor,\n                          resolve(data) {\n                            return (\n                              data.__cursor &&\n                              base64(JSON.stringify(data.__cursor))\n                            );\n                          },\n                        };\n                      },\n                      {\n                        isCursorField: true,\n                      }\n                    ),\n                    node: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"node\",\n                      {\n                        description: build.wrapDescription(\n                          `The \\`${tableTypeName}\\` at the end of the edge.`,\n                          \"field\"\n                        ),\n                        type: nullableIf(\n                          !pgForbidSetofFunctionsToReturnNull,\n                          TableType\n                        ),\n                        resolve(data, _args, resolveContext, resolveInfo) {\n                          const safeAlias =\n                            getSafeAliasFromResolveInfo(resolveInfo);\n                          const record = handleNullRow(\n                            data[safeAlias],\n                            data.__identifiers\n                          );\n                          const liveRecord =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveRecord;\n                          if (\n                            record &&\n                            primaryKeys &&\n                            liveRecord &&\n                            data.__identifiers\n                          ) {\n                            liveRecord(\"pg\", table, data.__identifiers);\n                          }\n                          return record;\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        withQueryBuilder: queryBuilder => {\n                          if (subscriptions) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                        },\n                      }\n                    ),\n                  };\n                },\n              },\n              {\n                __origin: `Adding table edge type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                isEdgeType: true,\n                isPgRowEdgeType: true,\n                nodeType: TableType,\n                pgIntrospection: table,\n              }\n            );\n            const PageInfo = getTypeByName(inflection.builtin(\"PageInfo\"));\n\n            /*const ConnectionType = */\n            newWithHooks(\n              GraphQLObjectType,\n              {\n                description: build.wrapDescription(\n                  `A connection to a list of \\`${tableTypeName}\\` values.`,\n                  \"type\"\n                ),\n                name: inflection.connection(TableType.name),\n                fields: ({ recurseDataGeneratorsForField, fieldWithHooks }) => {\n                  recurseDataGeneratorsForField(\"pageInfo\", true);\n                  return {\n                    nodes: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"nodes\",\n                      {\n                        description: build.wrapDescription(\n                          `A list of \\`${tableTypeName}\\` objects.`,\n                          \"field\"\n                        ),\n                        type: new GraphQLNonNull(\n                          new GraphQLList(\n                            nullableIf(\n                              !pgForbidSetofFunctionsToReturnNull,\n                              TableType\n                            )\n                          )\n                        ),\n                        resolve(data, _args, resolveContext, resolveInfo) {\n                          const safeAlias =\n                            getSafeAliasFromResolveInfo(resolveInfo);\n                          const liveRecord =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveRecord;\n                          return data.data.map(entry => {\n                            const record = handleNullRow(\n                              entry[safeAlias],\n                              entry[safeAlias].__identifiers\n                            );\n                            if (\n                              record &&\n                              liveRecord &&\n                              primaryKeys &&\n                              entry[safeAlias].__identifiers\n                            ) {\n                              liveRecord(\n                                \"pg\",\n                                table,\n                                entry[safeAlias].__identifiers\n                              );\n                            }\n\n                            return record;\n                          });\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        withQueryBuilder: queryBuilder => {\n                          if (subscriptions) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                        },\n                      }\n                    ),\n                    edges: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"edges\",\n                      {\n                        description: build.wrapDescription(\n                          `A list of edges which contains the \\`${tableTypeName}\\` and cursor to aid in pagination.`,\n                          \"field\"\n                        ),\n                        type: new GraphQLNonNull(\n                          new GraphQLList(new GraphQLNonNull(EdgeType))\n                        ),\n                        resolve(data, _args, _context, resolveInfo) {\n                          const safeAlias =\n                            getSafeAliasFromResolveInfo(resolveInfo);\n                          return data.data.map(entry => ({\n                            ...entry,\n                            ...entry[safeAlias],\n                          }));\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        hoistCursor: true,\n                      }\n                    ),\n                    pageInfo: PageInfo && {\n                      description: build.wrapDescription(\n                        \"Information to aid in pagination.\",\n                        \"field\"\n                      ),\n                      type: new GraphQLNonNull(PageInfo),\n                      resolve(data) {\n                        return data;\n                      },\n                    },\n                  };\n                },\n              },\n              {\n                __origin: `Adding table connection type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                isConnectionType: true,\n                isPgRowConnectionType: true,\n                edgeType: EdgeType,\n                nodeType: TableType,\n                pgIntrospection: table,\n              }\n            );\n          },\n          true\n        );\n        pgRegisterGqlInputTypeByTypeId(\n          tablePgType.id,\n          (_set, modifier) => {\n            // This must come first, it triggers creation of all the types\n            const TableType = pgGetGqlTypeByTypeIdAndModifier(\n              tablePgType.id,\n              null\n            );\n            // This must come after the pgGetGqlTypeByTypeIdAndModifier call\n            if (modifier === \"patch\") {\n              // TODO: v5: move the definition from above down here\n              return TablePatchType;\n            }\n            if (modifier === \"base\") {\n              // TODO: v5: move the definition from above down here\n              return TableBaseInputType;\n            }\n            if (TableType) {\n              return getTypeByName(inflection.inputType(TableType));\n            }\n            return null;\n          },\n          true\n        );\n\n        if (arrayTablePgType) {\n          // Note: these do not return\n          //\n          // `new GraphQLList(new GraphQLNonNull(...))`\n          //\n          // because it's possible to return null entries from postgresql\n          // functions. We should probably add a flag to instead export\n          // the non-null version as that's more typical.\n          pgRegisterGqlTypeByTypeId(\n            arrayTablePgType.id,\n            () => {\n              const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                tablePgType.id,\n                null\n              );\n              return new GraphQLList(TableType);\n            },\n            true\n          );\n          pgRegisterGqlInputTypeByTypeId(\n            arrayTablePgType.id,\n            (_set, modifier) => {\n              const RelevantTableInputType =\n                pgGetGqlInputTypeByTypeIdAndModifier(tablePgType.id, modifier);\n              if (RelevantTableInputType) {\n                return new GraphQLList(RelevantTableInputType);\n              }\n            },\n            true\n          );\n        }\n      });\n      return _;\n    },\n    [\"PgTables\"],\n    [],\n    [\"PgTypes\"]\n  );\n}: Plugin);\n"],"mappings":"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"}