{"version":3,"file":"PgMutationUpdateDeletePlugin.js","names":["_debug","_interopRequireDefault","require","obj","__esModule","default","debug","debugFactory","PgMutationUpdateDeletePlugin","builder","pgDisableDefaultMutations","hook","fields","build","context","newWithHooks","getNodeIdForTypeAndIdentifiers","getTypeAndIdentifiersFromNodeId","nodeIdFieldName","fieldDataGeneratorsByType","extend","parseResolveInfo","getTypeByName","gql2pg","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","graphql","GraphQLNonNull","GraphQLInputObjectType","GraphQLString","GraphQLObjectType","GraphQLID","pgColumnFilter","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","pgViaTemporaryTable","viaTemporaryTable","describePgEntity","sqlCommentByAddingTags","pgField","scope","isRootMutation","fieldWithHooks","reduce","outerMemo","mode","class","memo","table","namespace","canUpdate","isUpdatable","attributes","find","attr","canDelete","isDeletable","TableType","type","id","commonCodeRenameMe","pgClient","resolveInfo","getDataFromParsedResolveInfoFragment","PayloadType","args","condition","resolveContext","input","parsedResolveInfoFragment","resolveData","sqlTypeIdentifier","identifier","name","sqlMutationQuery","sqlColumns","sqlValues","inputData","patchField","tableFieldName","forEach","fieldName","column","val","push","typeModifier","length","query","join","map","col","i","fragment","modifiedRowAlias","Symbol","rootValue","row","rows","e","Error","pluralize","_singularizedTableName","clientMutationId","data","uniqueConstraints","constraints","filter","con","Table","tableTypeName","TablePatch","patchType","description","wrapDescription","tableName","deletedNodeIdFieldName","deletedNodeId","Object","assign","addDataGenerator","fieldDataGeneratorsByTableType","get","gens","gen","resolve","__identifiers","isPgMutationPayloadDeletedNodeIdField","__origin","isMutationPayload","isPgUpdatePayloadType","isPgDeletePayloadType","pgIntrospection","primaryKeyConstraint","primaryKeys","keyAttributes","InputType","isPgUpdateInputType","isPgUpdateNodeInputType","isPgDeleteInputType","isPgDeleteNodeInputType","pgInflection","isMutationInput","parent","nodeId","Type","identifiers","key","idx","isPgNodeMutation","pgFieldIntrospection","constraint","keys","every","_","some","typeId","isPgUpdateByKeysInputType","isPgDeleteByKeysInputType","pgKeys","pgFieldConstraint","exports"],"sources":["../../src/plugins/PgMutationUpdateDeletePlugin.js"],"sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugFactory from \"debug\";\n\nconst debug = debugFactory(\"graphile-build-pg\");\n\nexport default (async function PgMutationUpdateDeletePlugin(\n  builder,\n  { pgDisableDefaultMutations }\n) {\n  if (pgDisableDefaultMutations) {\n    return;\n  }\n\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        newWithHooks,\n        getNodeIdForTypeAndIdentifiers,\n        getTypeAndIdentifiersFromNodeId,\n        nodeIdFieldName,\n        fieldDataGeneratorsByType,\n        extend,\n        parseResolveInfo,\n        getTypeByName,\n        gql2pg,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        graphql: {\n          GraphQLNonNull,\n          GraphQLInputObjectType,\n          GraphQLString,\n          GraphQLObjectType,\n          GraphQLID,\n        },\n        pgColumnFilter,\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        pgViaTemporaryTable: viaTemporaryTable,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n      const {\n        scope: { isRootMutation },\n        fieldWithHooks,\n      } = context;\n\n      if (!isRootMutation) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        [\"update\", \"delete\"].reduce(\n          (outerMemo, mode) =>\n            introspectionResultsByKind.class.reduce((memo, table) => {\n              // PERFORMANCE: These used to be .filter(...) calls\n              if (!table.namespace) return memo;\n              const canUpdate =\n                mode === \"update\" &&\n                table.isUpdatable &&\n                !omit(table, \"update\") &&\n                // Check at least one attribute is updatable\n                table.attributes.find(attr => !omit(attr, \"update\"));\n              const canDelete =\n                mode === \"delete\" &&\n                table.isDeletable &&\n                !omit(table, \"delete\");\n              if (!canUpdate && !canDelete) return memo;\n\n              const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                table.type.id,\n                null\n              );\n              if (!TableType) {\n                return memo;\n              }\n              async function commonCodeRenameMe(\n                pgClient,\n                resolveInfo,\n                getDataFromParsedResolveInfoFragment,\n                PayloadType,\n                args,\n                condition,\n                context,\n                resolveContext\n              ) {\n                const { input } = args;\n                const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n                parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n                const resolveData = getDataFromParsedResolveInfoFragment(\n                  parsedResolveInfoFragment,\n                  PayloadType\n                );\n\n                const sqlTypeIdentifier = sql.identifier(\n                  table.namespace.name,\n                  table.name\n                );\n\n                let sqlMutationQuery;\n                if (mode === \"update\") {\n                  const sqlColumns = [];\n                  const sqlValues = [];\n                  const inputData =\n                    input[\n                      inflection.patchField(inflection.tableFieldName(table))\n                    ];\n                  table.attributes.forEach(attr => {\n                    // PERFORMANCE: These used to be .filter(...) calls\n                    if (!pgColumnFilter(attr, build, context)) return;\n                    if (omit(attr, \"update\")) return;\n\n                    const fieldName = inflection.column(attr);\n                    if (\n                      fieldName in inputData /* Because we care about null! */\n                    ) {\n                      const val = inputData[fieldName];\n                      sqlColumns.push(sql.identifier(attr.name));\n                      sqlValues.push(gql2pg(val, attr.type, attr.typeModifier));\n                    }\n                  });\n                  if (sqlColumns.length === 0) {\n                    return null;\n                  }\n                  sqlMutationQuery = sql.query`\\\nupdate ${sql.identifier(table.namespace.name, table.name)} set ${sql.join(\n                    sqlColumns.map(\n                      (col, i) => sql.fragment`${col} = ${sqlValues[i]}`\n                    ),\n                    \", \"\n                  )}\nwhere ${condition}\nreturning *`;\n                } else {\n                  sqlMutationQuery = sql.query`\\\ndelete from ${sql.identifier(table.namespace.name, table.name)}\nwhere ${condition}\nreturning *`;\n                }\n\n                const modifiedRowAlias = sql.identifier(Symbol());\n                const query = queryFromResolveData(\n                  modifiedRowAlias,\n                  modifiedRowAlias,\n                  resolveData,\n                  {},\n                  null,\n                  resolveContext,\n                  resolveInfo.rootValue\n                );\n                let row;\n                try {\n                  await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                  const rows = await viaTemporaryTable(\n                    pgClient,\n                    sqlTypeIdentifier,\n                    sqlMutationQuery,\n                    modifiedRowAlias,\n                    query\n                  );\n                  row = rows[0];\n                  await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                } catch (e) {\n                  await pgClient.query(\n                    \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                  );\n                  throw e;\n                }\n                if (!row) {\n                  throw new Error(\n                    `No values were ${mode}d in collection '${inflection.pluralize(\n                      inflection._singularizedTableName(table)\n                    )}' because no values you can ${mode} were found matching these criteria.`\n                  );\n                }\n                return {\n                  clientMutationId: input.clientMutationId,\n                  data: row,\n                };\n              }\n              if (TableType) {\n                const uniqueConstraints = table.constraints.filter(\n                  con => con.type === \"u\" || con.type === \"p\"\n                );\n                const Table = pgGetGqlTypeByTypeIdAndModifier(\n                  table.type.id,\n                  null\n                );\n                const tableTypeName = Table.name;\n                const TablePatch = getTypeByName(\n                  inflection.patchType(Table.name)\n                );\n                if (mode === \"update\" && !TablePatch) {\n                  return memo;\n                }\n                const PayloadType = newWithHooks(\n                  GraphQLObjectType,\n                  {\n                    name: inflection[\n                      mode === \"delete\"\n                        ? \"deletePayloadType\"\n                        : \"updatePayloadType\"\n                    ](table),\n                    description: build.wrapDescription(\n                      `The output of our ${mode} \\`${tableTypeName}\\` mutation.`,\n                      \"type\"\n                    ),\n                    fields: ({ fieldWithHooks }) => {\n                      const tableName = inflection.tableFieldName(table);\n                      // This should really be `-node-id` but for compatibility with PostGraphQL v3 we haven't made that change.\n                      const deletedNodeIdFieldName =\n                        inflection.deletedNodeId(table);\n                      return Object.assign(\n                        {\n                          clientMutationId: {\n                            description: build.wrapDescription(\n                              \"The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.\",\n                              \"field\"\n                            ),\n                            type: GraphQLString,\n                          },\n                          [tableName]: pgField(\n                            build,\n                            fieldWithHooks,\n                            tableName,\n                            {\n                              description: build.wrapDescription(\n                                `The \\`${tableTypeName}\\` that was ${mode}d by this mutation.`,\n                                \"field\"\n                              ),\n                              type: Table,\n                            },\n                            {},\n                            false\n                          ),\n                        },\n                        mode === \"delete\"\n                          ? {\n                              [deletedNodeIdFieldName]: fieldWithHooks(\n                                deletedNodeIdFieldName,\n                                ({ addDataGenerator }) => {\n                                  const fieldDataGeneratorsByTableType =\n                                    fieldDataGeneratorsByType.get(TableType);\n\n                                  const gens =\n                                    fieldDataGeneratorsByTableType &&\n                                    fieldDataGeneratorsByTableType[\n                                      nodeIdFieldName\n                                    ];\n                                  if (gens) {\n                                    gens.forEach(gen => addDataGenerator(gen));\n                                  }\n                                  return {\n                                    type: GraphQLID,\n                                    resolve(data) {\n                                      return (\n                                        data.data.__identifiers &&\n                                        getNodeIdForTypeAndIdentifiers(\n                                          Table,\n                                          ...data.data.__identifiers\n                                        )\n                                      );\n                                    },\n                                  };\n                                },\n                                {\n                                  isPgMutationPayloadDeletedNodeIdField: true,\n                                }\n                              ),\n                            }\n                          : null\n                      );\n                    },\n                  },\n                  {\n                    __origin: `Adding table ${mode} mutation payload type for ${describePgEntity(\n                      table\n                    )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                      table,\n                      {\n                        name: \"newNameHere\",\n                      }\n                    )}`,\n                    isMutationPayload: true,\n                    isPgUpdatePayloadType: mode === \"update\",\n                    isPgDeletePayloadType: mode === \"delete\",\n                    pgIntrospection: table,\n                  }\n                );\n\n                // NodeId\n                const primaryKeyConstraint = table.primaryKeyConstraint;\n                if (nodeIdFieldName && primaryKeyConstraint) {\n                  const primaryKeys =\n                    primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n                  const fieldName =\n                    inflection[mode === \"update\" ? \"updateNode\" : \"deleteNode\"](\n                      table\n                    );\n                  const InputType = newWithHooks(\n                    GraphQLInputObjectType,\n                    {\n                      description: build.wrapDescription(\n                        `All input for the \\`${fieldName}\\` mutation.`,\n                        \"type\"\n                      ),\n                      name: inflection[\n                        mode === \"update\"\n                          ? \"updateNodeInputType\"\n                          : \"deleteNodeInputType\"\n                      ](table),\n                      fields: Object.assign(\n                        {\n                          clientMutationId: {\n                            description: build.wrapDescription(\n                              \"An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.\",\n                              \"field\"\n                            ),\n                            type: GraphQLString,\n                          },\n                          [nodeIdFieldName]: {\n                            description: build.wrapDescription(\n                              `The globally unique \\`ID\\` which will identify a single \\`${tableTypeName}\\` to be ${mode}d.`,\n                              \"field\"\n                            ),\n                            type: new GraphQLNonNull(GraphQLID),\n                          },\n                        },\n                        mode === \"update\" && TablePatch\n                          ? {\n                              [inflection.patchField(\n                                inflection.tableFieldName(table)\n                              )]: {\n                                description: build.wrapDescription(\n                                  `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                  \"field\"\n                                ),\n                                type: new GraphQLNonNull(TablePatch),\n                              },\n                            }\n                          : null\n                      ),\n                    },\n                    {\n                      __origin: `Adding table ${mode} (by node ID) mutation input type for ${describePgEntity(\n                        table\n                      )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                        table,\n                        {\n                          name: \"newNameHere\",\n                        }\n                      )}`,\n                      isPgUpdateInputType: mode === \"update\",\n                      isPgUpdateNodeInputType: mode === \"update\",\n                      isPgDeleteInputType: mode === \"delete\",\n                      isPgDeleteNodeInputType: mode === \"delete\",\n                      pgInflection: table, // TODO:v5: remove - TYPO!\n                      pgIntrospection: table,\n                      isMutationInput: true,\n                    }\n                  );\n\n                  memo = extend(\n                    memo,\n                    {\n                      [fieldName]: fieldWithHooks(\n                        fieldName,\n                        context => {\n                          const { getDataFromParsedResolveInfoFragment } =\n                            context;\n                          return {\n                            description: build.wrapDescription(\n                              mode === \"update\"\n                                ? `Updates a single \\`${tableTypeName}\\` using its globally unique id and a patch.`\n                                : `Deletes a single \\`${tableTypeName}\\` using its globally unique id.`,\n                              \"field\"\n                            ),\n                            type: PayloadType,\n                            args: {\n                              input: {\n                                type: new GraphQLNonNull(InputType),\n                              },\n                            },\n                            async resolve(\n                              parent,\n                              args,\n                              resolveContext,\n                              resolveInfo\n                            ) {\n                              const { input } = args;\n                              const { pgClient } = resolveContext;\n                              const nodeId = input[nodeIdFieldName];\n                              try {\n                                const { Type, identifiers } =\n                                  getTypeAndIdentifiersFromNodeId(nodeId);\n                                if (Type !== TableType) {\n                                  throw new Error(\"Mismatched type\");\n                                }\n                                if (identifiers.length !== primaryKeys.length) {\n                                  throw new Error(\"Invalid ID\");\n                                }\n\n                                return commonCodeRenameMe(\n                                  pgClient,\n                                  resolveInfo,\n                                  getDataFromParsedResolveInfoFragment,\n                                  PayloadType,\n                                  args,\n                                  sql.fragment`(${sql.join(\n                                    primaryKeys.map(\n                                      (key, idx) =>\n                                        sql.fragment`${sql.identifier(\n                                          key.name\n                                        )} = ${gql2pg(\n                                          identifiers[idx],\n                                          key.type,\n                                          key.typeModifier\n                                        )}`\n                                    ),\n                                    \") and (\"\n                                  )})`,\n                                  context,\n                                  resolveContext\n                                );\n                              } catch (e) {\n                                debug(e);\n                                return null;\n                              }\n                            },\n                          };\n                        },\n                        {\n                          isPgNodeMutation: true,\n                          pgFieldIntrospection: table,\n                          [mode === \"update\"\n                            ? \"isPgUpdateMutationField\"\n                            : \"isPgDeleteMutationField\"]: true,\n                        }\n                      ),\n                    },\n                    \"Adding ${mode} mutation for ${describePgEntity(table)}\"\n                  );\n                }\n\n                // Unique\n                uniqueConstraints.forEach(constraint => {\n                  if (omit(constraint, mode)) {\n                    return;\n                  }\n                  const keys = constraint.keyAttributes;\n                  if (!keys.every(_ => _)) {\n                    throw new Error(\n                      `Consistency error: could not find an attribute in the constraint when building the ${mode} mutation for ${describePgEntity(\n                        table\n                      )}!`\n                    );\n                  }\n                  if (keys.some(key => omit(key, \"read\"))) {\n                    return;\n                  }\n                  const fieldName = inflection[\n                    mode === \"update\" ? \"updateByKeys\" : \"deleteByKeys\"\n                  ](keys, table, constraint);\n                  const InputType = newWithHooks(\n                    GraphQLInputObjectType,\n                    {\n                      description: build.wrapDescription(\n                        `All input for the \\`${fieldName}\\` mutation.`,\n                        \"type\"\n                      ),\n                      name: inflection[\n                        mode === \"update\"\n                          ? \"updateByKeysInputType\"\n                          : \"deleteByKeysInputType\"\n                      ](keys, table, constraint),\n                      fields: Object.assign(\n                        {\n                          clientMutationId: {\n                            type: GraphQLString,\n                          },\n                        },\n                        mode === \"update\" && TablePatch\n                          ? {\n                              [inflection.patchField(\n                                inflection.tableFieldName(table)\n                              )]: {\n                                description: build.wrapDescription(\n                                  `An object where the defined keys will be set on the \\`${tableTypeName}\\` being ${mode}d.`,\n                                  \"field\"\n                                ),\n                                type: new GraphQLNonNull(TablePatch),\n                              },\n                            }\n                          : null,\n                        keys.reduce((memo, key) => {\n                          memo[inflection.column(key)] = {\n                            description: key.description,\n                            type: new GraphQLNonNull(\n                              pgGetGqlInputTypeByTypeIdAndModifier(\n                                key.typeId,\n                                key.typeModifier\n                              )\n                            ),\n                          };\n                          return memo;\n                        }, {})\n                      ),\n                    },\n                    {\n                      __origin: `Adding table ${mode} mutation input type for ${describePgEntity(\n                        constraint\n                      )}. You can rename the table's GraphQL type via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                        table,\n                        {\n                          name: \"newNameHere\",\n                        }\n                      )}`,\n                      isPgUpdateInputType: mode === \"update\",\n                      isPgUpdateByKeysInputType: mode === \"update\",\n                      isPgDeleteInputType: mode === \"delete\",\n                      isPgDeleteByKeysInputType: mode === \"delete\",\n                      pgInflection: table, // TODO:v5: remove - TYPO!\n                      pgIntrospection: table,\n                      pgKeys: keys,\n                      isMutationInput: true,\n                    }\n                  );\n\n                  memo = extend(\n                    memo,\n                    {\n                      [fieldName]: fieldWithHooks(\n                        fieldName,\n                        context => {\n                          const { getDataFromParsedResolveInfoFragment } =\n                            context;\n                          return {\n                            description: build.wrapDescription(\n                              mode === \"update\"\n                                ? `Updates a single \\`${tableTypeName}\\` using a unique key and a patch.`\n                                : `Deletes a single \\`${tableTypeName}\\` using a unique key.`,\n                              \"field\"\n                            ),\n                            type: PayloadType,\n                            args: {\n                              input: {\n                                type: new GraphQLNonNull(InputType),\n                              },\n                            },\n                            async resolve(\n                              parent,\n                              args,\n                              resolveContext,\n                              resolveInfo\n                            ) {\n                              const { input } = args;\n                              const { pgClient } = resolveContext;\n                              return commonCodeRenameMe(\n                                pgClient,\n                                resolveInfo,\n                                getDataFromParsedResolveInfoFragment,\n                                PayloadType,\n                                args,\n                                sql.fragment`(${sql.join(\n                                  keys.map(\n                                    key =>\n                                      sql.fragment`${sql.identifier(\n                                        key.name\n                                      )} = ${gql2pg(\n                                        input[inflection.column(key)],\n                                        key.type,\n                                        key.typeModifier\n                                      )}`\n                                  ),\n                                  \") and (\"\n                                )})`,\n                                context,\n                                resolveContext\n                              );\n                            },\n                          };\n                        },\n                        {\n                          isPgNodeMutation: false,\n                          pgFieldIntrospection: table,\n                          pgFieldConstraint: constraint,\n                          [mode === \"update\"\n                            ? \"isPgUpdateMutationField\"\n                            : \"isPgDeleteMutationField\"]: true,\n                        }\n                      ),\n                    },\n                    `Adding ${mode} mutation for ${describePgEntity(\n                      constraint\n                    )}`\n                  );\n                });\n              }\n              return memo;\n            }, outerMemo),\n          {}\n        ),\n        `Adding default update/delete mutations to root Mutation type`\n      );\n    },\n    [\"PgMutationUpdateDelete\"]\n  );\n}: Plugin);\n"],"mappings":"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"}