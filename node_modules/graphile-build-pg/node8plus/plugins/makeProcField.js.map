{"version":3,"file":"makeProcField.js","names":["_debugSql","_interopRequireDefault","require","_chalk","obj","__esModule","default","nullableIf","GraphQLNonNull","condition","Type","firstValue","firstKey","k","procFieldDetails","proc","build","options","computed","isMutation","pgIntrospectionResultsByKind","introspectionResultsByKind","pgGetGqlInputTypeByTypeIdAndModifier","pgSql","sql","gql2pg","pgStrictFunctions","strictFunctions","graphql","inflection","describePgEntity","sqlCommentByAddingTags","Error","sliceAmount","argNames","argTypeIds","reduce","prev","_","idx","argModes","length","push","argTypes","typeId","typeById","argModesWithOutput","outputArgNames","includes","outputArgTypes","requiredArgCount","Math","max","argDefaultsNum","variantFromName","name","match","variantFromTags","tags","variant","parseInt","notNullArgCount","isStrict","argGqlTypes","map","type","id","hint","class","chalk","bold","green","inputs","memo","argName","argIndex","gqlArgName","argument","makeSqlFunctionCall","rawArgs","implicitArgs","unnest","args","input","sqlArgValues","haveNames","value","sqlValue","sqlArgName","identifier","unshift","fragment","functionCall","namespace","join","makeProcField","fieldName","fieldWithHooks","isRootQuery","forceList","aggregateWrapper","description","overrideDescription","pgTypeAndModifierModifier","pgGetGqlTypeByTypeIdAndModifier","getTypeByName","parseResolveInfo","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","pg2gql","newWithHooks","pgTweakFragmentForTypeAndModifier","GraphQLList","GraphQLString","GraphQLObjectType","GraphQLInputObjectType","getNamedType","isCompositeType","pgQueryFromResolveData","queryFromResolveData","pgAddStartEndCursor","addStartEndCursor","pgViaTemporaryTable","viaTemporaryTable","pgField","subscriptions","pgForbidSetofFunctionsToReturnNull","pgPrepareAndRun","baseReturnType","returnTypeId","rawReturnType","returnType","isPgArray","arrayItemType","returnTypeTable","classById","classId","fieldScope","payloadTypeScope","pgFieldIntrospection","pgIntrospection","returnFirstValueAsValue","TableType","isTableLike","isRecordLike","returnsSet","innerType","isPgFieldSimpleCollection","ConnectionType","connection","isPgFieldConnection","pgFieldIntrospectionTable","pgIntrospectionTable","RecordType","recordFunctionReturnType","recordFunctionConnection","connectionTypeName","scalarFunctionConnection","addDataGenerator","getDataFromParsedResolveInfoFragment","addArgDataGenerator","addPgCursorPrefix","pgCursorPrefix","literal","makeQuery","parsedResolveInfoFragment","ReturnType","sqlMutationQuery","functionAlias","parentQueryBuilder","resolveContext","resolveInfo","resolveData","isConnection","query","useAsterisk","language","withPagination","withPaginationAsFields","asJson","asJsonAggregate","addNullCase","innerQueryBuilder","select","primaryKeyConstraint","selectIdentifiers","context","rootValue","pgQuery","queryBuilder","parentTableAlias","getTableAlias","Symbol","sqlFunctionCall","alias","PayloadType","resultFieldName","functionMutationResultFieldName","isNotVoid","String","functionPayloadType","wrapDescription","functionMutationName","fields","Object","assign","clientMutationId","resolve","data","pgType","__origin","isMutationPayload","InputType","functionInputType","isMutationInput","scalarAwarePg2gql","v","notNull","_args","liveRecord","safeAlias","makeRecordLive","record","__identifiers","_record","records","pgClient","queryResultRows","intermediateIdentifier","isVoid","isPgRecord","isPgClass","namespaceName","e","text","values","compile","debugSql","enabled","queryResult","rows","row","result","fv"],"sources":["../../src/plugins/makeProcField.js"],"sourcesContent":["// @flow\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nimport type { Build, FieldWithHooksFunction } from \"graphile-build\";\nimport type { PgProc, PgType } from \"./PgIntrospectionPlugin\";\nimport type { SQL } from \"pg-sql2\";\nimport debugSql from \"./debugSql\";\nimport chalk from \"chalk\";\n\ntype ProcFieldOptions = {\n  fieldWithHooks: FieldWithHooksFunction,\n  computed?: boolean,\n  isMutation?: boolean,\n  isRootQuery?: boolean,\n  forceList?: boolean,\n  aggregateWrapper?: null | ((sql: SQL) => SQL),\n  description?: string,\n  pgTypeAndModifierModifier?:\n    | null\n    | ((\n        pgType: PgType,\n        pgTypeModifier: null | string | number\n      ) => [PgType, null | string | number]),\n};\n\nconst firstValue = obj => {\n  let firstKey;\n  for (const k in obj) {\n    if (k[0] !== \"_\" && k[1] !== \"_\") {\n      firstKey = k;\n    }\n  }\n  return obj[firstKey];\n};\n\nexport function procFieldDetails(\n  proc: PgProc,\n  build: {| ...Build |},\n  options: {\n    computed?: boolean,\n    isMutation?: boolean,\n  }\n) {\n  const { computed = false, isMutation = false } = options;\n  const {\n    pgIntrospectionResultsByKind: introspectionResultsByKind,\n    pgGetGqlInputTypeByTypeIdAndModifier,\n    pgSql: sql,\n    gql2pg,\n    pgStrictFunctions: strictFunctions,\n    graphql: { GraphQLNonNull },\n    inflection,\n    describePgEntity,\n    sqlCommentByAddingTags,\n  } = build;\n\n  if (computed && isMutation) {\n    throw new Error(\"Mutation procedure cannot be computed\");\n  }\n\n  const sliceAmount = computed ? 1 : 0;\n  const argNames = proc.argTypeIds.reduce((prev, _, idx) => {\n    if (\n      idx >= sliceAmount && // Was a .slice() call\n      (proc.argModes.length === 0 || // all args are `in`\n        proc.argModes[idx] === \"i\" || // this arg is `in`\n        proc.argModes[idx] === \"b\") // this arg is `inout`\n    ) {\n      prev.push(proc.argNames[idx] || \"\");\n    }\n    return prev;\n  }, []);\n  const argTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n    if (\n      idx >= sliceAmount && // Was a .slice() call\n      (proc.argModes.length === 0 || // all args are `in`\n        proc.argModes[idx] === \"i\" || // this arg is `in`\n        proc.argModes[idx] === \"b\") // this arg is `inout`\n    ) {\n      prev.push(introspectionResultsByKind.typeById[typeId]);\n    }\n    return prev;\n  }, []);\n  const argModesWithOutput = [\n    \"o\", // OUT,\n    \"b\", // INOUT\n    \"t\", // TABLE\n  ];\n  const outputArgNames = proc.argTypeIds.reduce((prev, _, idx) => {\n    if (argModesWithOutput.includes(proc.argModes[idx])) {\n      prev.push(proc.argNames[idx] || \"\");\n    }\n    return prev;\n  }, []);\n  const outputArgTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n    if (argModesWithOutput.includes(proc.argModes[idx])) {\n      prev.push(introspectionResultsByKind.typeById[typeId]);\n    }\n    return prev;\n  }, []);\n  const requiredArgCount = Math.max(0, argNames.length - proc.argDefaultsNum);\n  const variantFromName = name => {\n    if (name.match(/(_p|P)atch$/)) {\n      return \"patch\";\n    }\n    return null;\n  };\n  const variantFromTags = (tags, idx) => {\n    const variant = tags[`arg${idx}variant`];\n    if (variant && variant.match && variant.match(/^[0-9]+$/)) {\n      return parseInt(variant, 10);\n    }\n    return variant;\n  };\n  const notNullArgCount =\n    proc.isStrict || strictFunctions ? requiredArgCount : 0;\n  const argGqlTypes = argTypes.map((type, idx) => {\n    // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod on function return values, but maybe a later version might\n    const variant =\n      variantFromTags(proc.tags, idx) || variantFromName(argNames[idx]);\n    const Type = pgGetGqlInputTypeByTypeIdAndModifier(type.id, variant);\n    if (!Type) {\n      const hint = type.class\n        ? `; this might be because no INSERT column privileges are granted on ${describePgEntity(\n            type.class\n          )}. You can use 'Smart Comments' to tell PostGraphile to instead use the \"${chalk.bold.green(\n            \"base\"\n          )}\" input type which includes all columns:\\n\\n  ${sqlCommentByAddingTags(\n            proc,\n            {\n              [`arg${idx}variant`]: \"base\",\n            }\n          )}\\n`\n        : \"\";\n      throw new Error(\n        `Could not determine type for argument ${idx} ('${\n          argNames[idx]\n        }') of function ${describePgEntity(proc)}${hint}`\n      );\n    }\n    if (idx >= notNullArgCount) {\n      return Type;\n    } else {\n      return new GraphQLNonNull(Type);\n    }\n  });\n  // This wants to be compatible with both being field arguments and being\n  // input object fields (e.g. for the aggregates plugin).\n  const inputs = argNames.reduce((memo, argName, argIndex) => {\n    const gqlArgName = inflection.argument(argName, argIndex);\n    memo[gqlArgName] = {\n      type: argGqlTypes[argIndex],\n    };\n    return memo;\n  }, {});\n\n  function makeSqlFunctionCall(\n    rawArgs = {},\n    { implicitArgs = [], unnest = false } = {}\n  ): SQL {\n    const args = isMutation ? rawArgs.input : rawArgs;\n    const sqlArgValues = [];\n    let haveNames = true;\n    for (let argIndex = argNames.length - 1; argIndex >= 0; argIndex--) {\n      const argName = argNames[argIndex];\n      const gqlArgName = inflection.argument(argName, argIndex);\n      const value = args[gqlArgName];\n      const variant =\n        variantFromTags(proc.tags, argIndex) ||\n        variantFromName(argNames[argIndex]);\n\n      const sqlValue = gql2pg(value, argTypes[argIndex], variant);\n\n      if (argIndex + 1 > requiredArgCount && haveNames && value == null) {\n        // No need to pass argument to function\n        continue;\n      } else if (argIndex + 1 > requiredArgCount && haveNames) {\n        const sqlArgName = argName ? sql.identifier(argName) : null;\n        if (sqlArgName) {\n          sqlArgValues.unshift(sql.fragment`${sqlArgName} := ${sqlValue}`);\n        } else {\n          haveNames = false;\n          sqlArgValues.unshift(sqlValue);\n        }\n      } else {\n        sqlArgValues.unshift(sqlValue);\n      }\n    }\n    const functionCall = sql.fragment`${sql.identifier(\n      proc.namespace.name,\n      proc.name\n    )}(${sql.join([...implicitArgs, ...sqlArgValues], \", \")})`;\n    return unnest ? sql.fragment`unnest(${functionCall})` : functionCall;\n  }\n\n  return {\n    inputs,\n    makeSqlFunctionCall,\n    outputArgNames,\n    outputArgTypes,\n  };\n}\n\nexport default function makeProcField(\n  fieldName: string,\n  proc: PgProc,\n  build: {| ...Build |},\n  options: ProcFieldOptions\n) {\n  const {\n    fieldWithHooks,\n    computed = false,\n    isMutation = false,\n    isRootQuery = false,\n    forceList = false,\n    aggregateWrapper = null,\n    description: overrideDescription = null,\n    pgTypeAndModifierModifier = null,\n  } = options;\n  const {\n    pgIntrospectionResultsByKind: introspectionResultsByKind,\n    pgGetGqlTypeByTypeIdAndModifier,\n    getTypeByName,\n    pgSql: sql,\n    parseResolveInfo,\n    getSafeAliasFromResolveInfo,\n    getSafeAliasFromAlias,\n    pg2gql,\n    newWithHooks,\n    pgTweakFragmentForTypeAndModifier,\n    graphql: {\n      GraphQLNonNull,\n      GraphQLList,\n      GraphQLString,\n      GraphQLObjectType,\n      GraphQLInputObjectType,\n      getNamedType,\n      isCompositeType,\n    },\n    inflection,\n    pgQueryFromResolveData: queryFromResolveData,\n    pgAddStartEndCursor: addStartEndCursor,\n    pgViaTemporaryTable: viaTemporaryTable,\n    describePgEntity,\n    sqlCommentByAddingTags,\n    pgField,\n    options: {\n      subscriptions = false,\n      pgForbidSetofFunctionsToReturnNull = false,\n    },\n    pgPrepareAndRun,\n  } = build;\n\n  const { inputs, makeSqlFunctionCall, outputArgNames, outputArgTypes } =\n    procFieldDetails(proc, build, options);\n  let args = inputs;\n\n  /**\n   * This is the return type the function claims to have; we\n   * should not use it anywhere but these next few lines.\n   */\n  const baseReturnType = introspectionResultsByKind.typeById[proc.returnTypeId];\n\n  /**\n   * This is the return type we treat it as having, e.g. in\n   * case it was modified by wrapping it in an aggregate or\n   * similar.\n   */\n  const rawReturnType = pgTypeAndModifierModifier\n    ? pgTypeAndModifierModifier(baseReturnType, null)[0]\n    : baseReturnType;\n\n  /**\n   * This is the type without the array wrapper.\n   */\n  const returnType = rawReturnType.isPgArray\n    ? rawReturnType.arrayItemType\n    : rawReturnType;\n  const returnTypeTable =\n    introspectionResultsByKind.classById[returnType.classId];\n  if (!returnType) {\n    throw new Error(\n      `Could not determine return type for function '${proc.name}'`\n    );\n  }\n  let type;\n  const fieldScope = {};\n  const payloadTypeScope = {};\n  fieldScope.pgFieldIntrospection = proc;\n  payloadTypeScope.pgIntrospection = proc;\n  let returnFirstValueAsValue = false;\n  const TableType =\n    returnTypeTable &&\n    pgGetGqlTypeByTypeIdAndModifier(returnTypeTable.type.id, null);\n\n  const isTableLike: boolean =\n    (TableType && isCompositeType(TableType)) || false;\n  const isRecordLike = returnType.id === \"2249\";\n  if (isTableLike) {\n    if (proc.returnsSet) {\n      if (isMutation) {\n        const innerType = pgForbidSetofFunctionsToReturnNull\n          ? new GraphQLNonNull(TableType)\n          : TableType;\n        type = new GraphQLList(innerType);\n      } else if (forceList) {\n        const innerType = pgForbidSetofFunctionsToReturnNull\n          ? new GraphQLNonNull(TableType)\n          : TableType;\n        type = new GraphQLList(innerType);\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        const ConnectionType = getTypeByName(\n          inflection.connection(TableType.name)\n        );\n        if (!ConnectionType) {\n          throw new Error(\n            `Do not have a connection type '${inflection.connection(\n              TableType.name\n            )}' for '${TableType.name}' so cannot create procedure field`\n          );\n        }\n        type = ConnectionType;\n        fieldScope.isPgFieldConnection = true;\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    } else {\n      type = TableType;\n      if (rawReturnType.isPgArray) {\n        // Not implementing pgForbidSetofFunctionsToReturnNull here because it's not a set\n        type = new GraphQLList(type);\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    }\n  } else if (isRecordLike) {\n    const RecordType = getTypeByName(inflection.recordFunctionReturnType(proc));\n    if (!RecordType) {\n      throw new Error(\n        `Do not have a record type '${inflection.recordFunctionReturnType(\n          proc\n        )}' for '${proc.name}' so cannot create procedure field`\n      );\n    }\n    if (proc.returnsSet) {\n      if (isMutation) {\n        type = new GraphQLList(RecordType);\n      } else if (forceList) {\n        type = new GraphQLList(RecordType);\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        const ConnectionType = getTypeByName(\n          inflection.recordFunctionConnection(proc)\n        );\n        if (!ConnectionType) {\n          throw new Error(\n            `Do not have a connection type '${inflection.recordFunctionConnection(\n              proc\n            )}' for '${RecordType.name}' so cannot create procedure field`\n          );\n        }\n        type = ConnectionType;\n        fieldScope.isPgFieldConnection = true;\n      }\n    } else {\n      type = RecordType;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n    }\n  } else {\n    // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod on function return values, but maybe a later version might\n    const Type =\n      pgGetGqlTypeByTypeIdAndModifier(returnType.id, null) || GraphQLString;\n\n    if (proc.returnsSet) {\n      const connectionTypeName = inflection.scalarFunctionConnection(proc);\n      const ConnectionType = getTypeByName(connectionTypeName);\n      if (isMutation) {\n        // Cannot return a connection because it would have to run the mutation again\n        type = new GraphQLList(Type);\n        returnFirstValueAsValue = true;\n      } else if (forceList || !ConnectionType) {\n        type = new GraphQLList(Type);\n        returnFirstValueAsValue = true;\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        type = ConnectionType;\n        fieldScope.isPgFieldConnection = true;\n        // We don't return the first value as the value here because it gets\n        // sent down into PgScalarFunctionConnectionPlugin so the relevant\n        // EdgeType can return cursor / node; i.e. we might want to add an\n        // `__cursor` field so we can't just use a scalar.\n      }\n    } else {\n      returnFirstValueAsValue = true;\n      type = Type;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n    }\n  }\n  return fieldWithHooks(\n    fieldName,\n    ({\n      addDataGenerator,\n      getDataFromParsedResolveInfoFragment,\n      addArgDataGenerator,\n    }) => {\n      if (\n        proc.returnsSet &&\n        !isTableLike &&\n        !returnFirstValueAsValue &&\n        !isMutation\n      ) {\n        // Natural ordering\n        addArgDataGenerator(function addPgCursorPrefix() {\n          return {\n            pgCursorPrefix: sql.literal(\"natural\"),\n          };\n        });\n      }\n      function makeQuery(\n        parsedResolveInfoFragment,\n        ReturnType,\n        sqlMutationQuery,\n        functionAlias,\n        parentQueryBuilder,\n        resolveContext,\n        resolveInfo\n      ) {\n        const resolveData = getDataFromParsedResolveInfoFragment(\n          parsedResolveInfoFragment,\n          ReturnType\n        );\n        const isConnection = !forceList && !isMutation && proc.returnsSet;\n        const query = queryFromResolveData(\n          sqlMutationQuery,\n          functionAlias,\n          resolveData,\n          {\n            useAsterisk:\n              !isMutation &&\n              (isTableLike || isRecordLike) &&\n              (forceList || proc.returnsSet || rawReturnType.isPgArray) && // only bother with lists\n              proc.language !== \"sql\", // sql functions can be inlined, so GRANTs still apply\n            withPagination: isConnection,\n            withPaginationAsFields: isConnection && !computed,\n            asJson:\n              computed &&\n              (forceList || (!proc.returnsSet && !returnFirstValueAsValue)),\n            asJsonAggregate:\n              computed &&\n              (forceList || (!proc.returnsSet && rawReturnType.isPgArray)),\n            addNullCase:\n              !proc.returnsSet &&\n              !rawReturnType.isPgArray &&\n              (isTableLike || isRecordLike),\n          },\n          innerQueryBuilder => {\n            innerQueryBuilder.parentQueryBuilder = parentQueryBuilder;\n            if (!isTableLike) {\n              if (returnTypeTable) {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForTypeAndModifier(\n                    sql.fragment`${functionAlias}`,\n                    returnTypeTable.type,\n                    null,\n                    resolveData\n                  ),\n                  \"value\"\n                );\n              } else {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForTypeAndModifier(\n                    sql.fragment`${functionAlias}`,\n                    returnType,\n                    null, // We can't determine a type modifier for functions\n                    resolveData\n                  ),\n                  \"value\"\n                );\n              }\n            } else if (\n              subscriptions &&\n              returnTypeTable &&\n              !isConnection &&\n              returnTypeTable.primaryKeyConstraint\n            ) {\n              innerQueryBuilder.selectIdentifiers(returnTypeTable);\n            }\n          },\n          parentQueryBuilder ? parentQueryBuilder.context : resolveContext,\n          parentQueryBuilder\n            ? parentQueryBuilder.rootValue\n            : resolveInfo && resolveInfo.rootValue\n        );\n        return query;\n      }\n      if (computed) {\n        addDataGenerator((parsedResolveInfoFragment, ReturnType) => {\n          return {\n            pgQuery: queryBuilder => {\n              queryBuilder.select(() => {\n                const parentTableAlias = queryBuilder.getTableAlias();\n                const functionAlias = sql.identifier(Symbol());\n                const sqlFunctionCall = makeSqlFunctionCall(\n                  parsedResolveInfoFragment.args,\n                  {\n                    implicitArgs: [parentTableAlias],\n                    unnest: rawReturnType.isPgArray,\n                  }\n                );\n                if (aggregateWrapper) {\n                  return aggregateWrapper(sqlFunctionCall);\n                } else {\n                  const query = makeQuery(\n                    parsedResolveInfoFragment,\n                    ReturnType,\n                    sqlFunctionCall,\n                    functionAlias,\n                    queryBuilder\n                  );\n                  return sql.fragment`(${query})`;\n                }\n              }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n            },\n          };\n        });\n      }\n\n      let ReturnType = type;\n      let PayloadType;\n      if (isMutation) {\n        const resultFieldName = inflection.functionMutationResultFieldName(\n          proc,\n          getNamedType(type),\n          proc.returnsSet || rawReturnType.isPgArray,\n          outputArgNames\n        );\n        const isNotVoid = String(returnType.id) !== \"2278\";\n        // If set then plural name\n        PayloadType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.functionPayloadType(proc),\n            description: build.wrapDescription(\n              `The output of our \\`${inflection.functionMutationName(\n                proc\n              )}\\` mutation.`,\n              \"type\"\n            ),\n            fields: ({ fieldWithHooks }) => {\n              return Object.assign(\n                {},\n                {\n                  clientMutationId: {\n                    type: GraphQLString,\n                  },\n                },\n                isNotVoid\n                  ? {\n                      [resultFieldName]: pgField(\n                        build,\n                        fieldWithHooks,\n                        resultFieldName,\n                        {\n                          type: type,\n                          ...(returnFirstValueAsValue\n                            ? {\n                                resolve(data) {\n                                  return data.data;\n                                },\n                              }\n                            : null),\n                        },\n                        {},\n                        false,\n                        {\n                          pgType: returnType,\n                        }\n                      ),\n                      // Result\n                    }\n                  : null\n              );\n            },\n          },\n          {\n            __origin: `Adding mutation function payload type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isMutationPayload: true,\n            ...payloadTypeScope,\n          }\n        );\n        ReturnType = PayloadType;\n        const InputType = newWithHooks(\n          GraphQLInputObjectType,\n          {\n            name: inflection.functionInputType(proc),\n            description: build.wrapDescription(\n              `All input for the \\`${inflection.functionMutationName(\n                proc\n              )}\\` mutation.`,\n              \"type\"\n            ),\n            fields: {\n              clientMutationId: {\n                type: GraphQLString,\n              },\n              ...args,\n            },\n          },\n          {\n            __origin: `Adding mutation function input type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isMutationInput: true,\n          }\n        );\n        args = {\n          input: {\n            type: new GraphQLNonNull(InputType),\n          },\n        };\n      }\n      // If this is a table we can process it directly; but if it's a scalar\n      // setof function we must dereference '.value' from it, because this\n      // makes space for '__cursor' to exist alongside it (whereas on a table\n      // the '__cursor' can just be on the table object itself)\n      const scalarAwarePg2gql = v =>\n        isTableLike\n          ? pg2gql(v, returnType)\n          : {\n              ...v,\n              value: pg2gql(v.value, returnType),\n            };\n\n      return {\n        description: overrideDescription\n          ? overrideDescription\n          : proc.description\n          ? proc.description\n          : isMutation\n          ? null\n          : isTableLike && proc.returnsSet\n          ? build.wrapDescription(\n              `Reads and enables pagination through a set of \\`${TableType.name}\\`.`,\n              \"field\"\n            )\n          : null,\n        type: nullableIf(\n          GraphQLNonNull,\n          !proc.tags.notNull &&\n            (!fieldScope.isPgFieldConnection || isMutation || isRootQuery),\n          ReturnType\n        ),\n        args: args,\n        resolve: computed\n          ? (data, _args, resolveContext, resolveInfo) => {\n              const liveRecord =\n                resolveInfo.rootValue && resolveInfo.rootValue.liveRecord;\n              const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n              const value = data[safeAlias];\n              if (returnFirstValueAsValue) {\n                // Is not table like; is not record like.\n                if (proc.returnsSet && !forceList) {\n                  // EITHER `isMutation` is true, or `ConnectionType` does not\n                  // exist - either way, we're not returning a connection.\n                  return value.data.map(v => pg2gql(firstValue(v), returnType));\n                } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                  return value.map(v => pg2gql(firstValue(v), returnType));\n                } else {\n                  return pg2gql(value, returnType);\n                }\n              } else {\n                const makeRecordLive =\n                  subscriptions && isTableLike && returnTypeTable && liveRecord\n                    ? record => {\n                        if (record) {\n                          liveRecord(\n                            \"pg\",\n                            returnTypeTable,\n                            record.__identifiers\n                          );\n                        }\n                      }\n                    : _record => {};\n                if (proc.returnsSet && !isMutation && !forceList) {\n                  // Connection - do not make live (the connection will handle this)\n                  return addStartEndCursor({\n                    ...value,\n                    data: value.data ? value.data.map(scalarAwarePg2gql) : null,\n                  });\n                } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                  // List\n                  const records = value.map(v => {\n                    makeRecordLive(v);\n                    return pg2gql(v, returnType);\n                  });\n                  return records;\n                } else {\n                  // Object\n                  if (value) {\n                    makeRecordLive(value);\n                  }\n                  return pg2gql(value, returnType);\n                }\n              }\n            }\n          : async (data, args, resolveContext, resolveInfo) => {\n              const { pgClient } = resolveContext;\n              const liveRecord =\n                resolveInfo.rootValue && resolveInfo.rootValue.liveRecord;\n              const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n              parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n              const functionAlias = sql.identifier(Symbol());\n              const sqlFunctionCall = makeSqlFunctionCall(\n                parsedResolveInfoFragment.args,\n                {\n                  unnest: rawReturnType.isPgArray,\n                }\n              );\n\n              let queryResultRows;\n              if (isMutation) {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  functionAlias,\n                  functionAlias,\n                  null,\n                  resolveContext,\n                  resolveInfo\n                );\n                const intermediateIdentifier = sql.identifier(Symbol());\n                const isVoid = returnType.id === \"2278\";\n                const isPgRecord = returnType.id === \"2249\";\n                const isPgClass =\n                  !isPgRecord &&\n                  (!returnFirstValueAsValue || returnTypeTable || false);\n                try {\n                  await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                  queryResultRows = await viaTemporaryTable(\n                    pgClient,\n                    isVoid\n                      ? null\n                      : sql.identifier(\n                          returnType.namespaceName,\n                          returnType.name\n                        ),\n                    sql.query`select ${\n                      isPgClass\n                        ? sql.query`${intermediateIdentifier}.*`\n                        : isPgRecord\n                        ? sql.query`${intermediateIdentifier}.*`\n                        : sql.query`${intermediateIdentifier} as ${functionAlias}`\n                    } from ${sqlFunctionCall} ${intermediateIdentifier}`,\n                    functionAlias,\n                    query,\n                    isPgClass,\n                    isPgRecord\n                      ? {\n                          outputArgTypes,\n                          outputArgNames,\n                        }\n                      : null\n                  );\n                  await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                } catch (e) {\n                  await pgClient.query(\n                    \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                  );\n                  throw e;\n                }\n              } else {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  sqlFunctionCall,\n                  functionAlias,\n                  null,\n                  resolveContext,\n                  resolveInfo\n                );\n                const { text, values } = sql.compile(query);\n                if (debugSql.enabled) debugSql(text);\n                const queryResult = await pgPrepareAndRun(\n                  pgClient,\n                  text,\n                  values\n                );\n                queryResultRows = queryResult.rows;\n              }\n              const rows = queryResultRows;\n              const [row] = rows;\n              const result = (() => {\n                const makeRecordLive =\n                  subscriptions && isTableLike && returnTypeTable && liveRecord\n                    ? record => {\n                        if (record) {\n                          liveRecord(\n                            \"pg\",\n                            returnTypeTable,\n                            record.__identifiers\n                          );\n                        }\n                      }\n                    : _record => {};\n                if (returnFirstValueAsValue) {\n                  // `returnFirstValueAsValue` implies either `isMutation` is\n                  // true, or `ConnectionType` does not exist - either way,\n                  // we're not returning a connection.\n                  if (proc.returnsSet && !isMutation && !forceList) {\n                    return row.data.map(v => {\n                      const fv = firstValue(v);\n                      makeRecordLive(fv);\n                      return pg2gql(fv, returnType);\n                    });\n                  } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                    return rows.map(v => {\n                      const fv = firstValue(v);\n                      makeRecordLive(fv);\n                      return pg2gql(fv, returnType);\n                    });\n                  } else {\n                    const fv = firstValue(row);\n                    makeRecordLive(fv);\n                    const record = pg2gql(fv, returnType);\n                    return record;\n                  }\n                } else {\n                  if (proc.returnsSet && !isMutation && !forceList) {\n                    // Connection\n                    const data = row.data\n                      ? row.data.map(scalarAwarePg2gql)\n                      : null;\n                    return addStartEndCursor({\n                      ...row,\n                      data,\n                    });\n                  } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                    // List\n                    return rows.map(row => {\n                      makeRecordLive(row);\n                      return pg2gql(row, returnType);\n                    });\n                  } else {\n                    // Object\n                    makeRecordLive(row);\n                    return pg2gql(row, returnType);\n                  }\n                }\n              })();\n              if (isMutation) {\n                return {\n                  clientMutationId: args.input.clientMutationId,\n                  data: result,\n                };\n              } else {\n                return result;\n              }\n            },\n      };\n    },\n    fieldScope\n  );\n}\n"],"mappings":"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"}