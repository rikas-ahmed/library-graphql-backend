{"version":3,"file":"viaTemporaryTable.js","names":["sql","_interopRequireWildcard","require","_debugSql","_interopRequireDefault","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","viaTemporaryTable","pgClient","sqlTypeIdentifier","sqlMutationQuery","sqlResultSourceAlias","sqlResultQuery","isPgClassLike","pgRecordInfo","undefined","isPgRecord","outputArgTypes","outputArgNames","performQuery","sqlQuery","text","values","compile","debugSql","enabled","query","rows","selectionField","join","map","outputArgName","idx","identifier","result","firstNonNullRow","find","row","firstKey","keys","rawValues","filter","rawValue","sqlValuesAlias","Symbol","convertFieldBack","value","literal","isFake","namespaceName","name","filteredValuesResults","length","finalRows","__isNull","shift"],"sources":["../../src/plugins/viaTemporaryTable.js"],"sourcesContent":["// @flow\n\nimport * as sql from \"pg-sql2\";\nimport type { Client } from \"pg\";\nimport type { SQL, SQLQuery } from \"pg-sql2\";\nimport debugSql from \"./debugSql\";\n\n/*\n * Originally we tried this with a CTE, but:\n *\n * > The sub-statements in WITH are executed concurrently with each other and\n * > with the main query. Therefore, when using data-modifying statements in\n * > WITH, the order in which the specified updates actually happen is\n * > unpredictable. All the statements are executed with the same snapshot (see\n * > Chapter 13), so they cannot \"see\" one another's effects on the target\n * > tables. This alleviates the effects of the unpredictability of the actual\n * > order of row updates, and means that RETURNING data is the only way to\n * > communicate changes between different WITH sub-statements and the main\n * > query.\n *\n * -- https://www.postgresql.org/docs/9.6/static/queries-with.html\n *\n * This caused issues with computed columns that themselves went off and\n * performed selects - because the data within those selects used the old\n * snapshot and thus returned stale data.\n *\n * To solve this, we tried using temporary tables to ensure the mutation and\n * the select execute in different statments. This worked, but temporary tables\n * require elevated priviliges and thus don't work everywhere. We needed a more\n * generic solution.\n *\n * In the end we settled for sending the data we received from the mutations\n * straight back into the PostgreSQL server. It's a bit wasteful but it works.\n *\n * If you can come up with a better solution please open a pull request!\n */\n\nexport default async function viaTemporaryTable(\n  pgClient: Client,\n  sqlTypeIdentifier: ?SQL,\n  sqlMutationQuery: SQL,\n  sqlResultSourceAlias: SQL,\n  sqlResultQuery: SQL,\n  isPgClassLike: boolean = true,\n  pgRecordInfo: ?{\n    // eslint-disable-next-line flowtype/no-weak-types\n    outputArgTypes: Array<any>,\n    outputArgNames: Array<string>,\n  } = undefined\n) {\n  const isPgRecord = pgRecordInfo != null;\n  const { outputArgTypes, outputArgNames } = pgRecordInfo || {};\n\n  async function performQuery(pgClient: Client, sqlQuery: SQLQuery) {\n    // TODO: look into rowMode = 'array'\n    const { text, values } = sql.compile(sqlQuery);\n    if (debugSql.enabled) debugSql(text);\n    return pgClient.query(text, values);\n  }\n\n  if (!sqlTypeIdentifier) {\n    // It returns void, just perform the query!\n    const { rows } = await performQuery(\n      pgClient,\n      sql.query`with ${sqlResultSourceAlias} as (${sqlMutationQuery}) ${sqlResultQuery}`\n    );\n    return rows;\n  } else {\n    /*\n     * In this code we're converting the rows to a string representation within\n     * PostgreSQL itself, then we can send it back into PostgreSQL and have it\n     * re-interpret the results cleanly (using it's own serializer/parser\n     * combination) so we should be fairly confident that it will work\n     * correctly every time assuming none of the PostgreSQL types are broken.\n     *\n     * If you have a way to improve this, I'd love to see a PR - but please\n     * make sure that the integration tests pass with your solution first as\n     * there are a log of potential pitfalls!\n     */\n    const selectionField = isPgClassLike\n      ? /*\n         * This `when foo is null then null` check might *seem* redundant, but it\n         * is not - e.g. the compound type `(,,,,,,,)::my_type` and\n         * `null::my_type` differ; however the former also returns true to `foo\n         * is null`. We use this check to coalesce both into the canonical `null`\n         * representation to make it easier to deal with below.\n         */\n        sql.query`(case when ${sqlResultSourceAlias} is null then null else ${sqlResultSourceAlias} end)`\n      : isPgRecord\n      ? sql.query`array[${sql.join(\n          outputArgNames.map(\n            (outputArgName, idx) =>\n              sql.query`${sqlResultSourceAlias}.${sql.identifier(\n                // According to https://www.postgresql.org/docs/10/static/sql-createfunction.html,\n                // \"If you omit the name for an output argument, the system will choose a default column name.\"\n                // In PG 9.x and 10, the column names appear to be assigned with a `column` prefix.\n                outputArgName !== \"\" ? outputArgName : `column${idx + 1}`\n              )}::text`\n          ),\n          \" ,\"\n        )}]`\n      : sql.query`(${sqlResultSourceAlias}.${sqlResultSourceAlias})::${sqlTypeIdentifier}`;\n    const result = await performQuery(\n      pgClient,\n      sql.query`with ${sqlResultSourceAlias} as (${sqlMutationQuery}) select (${selectionField})::text from ${sqlResultSourceAlias}`\n    );\n    const { rows } = result;\n    const firstNonNullRow = rows.find(row => row !== null);\n    // TODO: we should be able to have `pg` not interpret the results as\n    // objects and instead just return them as arrays - then we can just do\n    // `row[0]`. PR welcome!\n    const firstKey = firstNonNullRow && Object.keys(firstNonNullRow)[0];\n    const rawValues = rows.map(row => row && row[firstKey]);\n    const values = rawValues.filter(rawValue => rawValue !== null);\n    const sqlValuesAlias = sql.identifier(Symbol());\n    const convertFieldBack = isPgClassLike\n      ? sql.query`\\\nselect (str::${sqlTypeIdentifier}).*\nfrom unnest((${sql.value(values)})::text[]) str`\n      : isPgRecord\n      ? sql.query`\\\nselect ${sql.join(\n          outputArgNames.map(\n            (outputArgName, idx) =>\n              sql.query`(${sqlValuesAlias}.output_value_list)[${sql.literal(\n                idx + 1\n              )}]::${\n                outputArgTypes[idx].isFake\n                  ? sql.identifier(\"unknown\")\n                  : sql.identifier(\n                      outputArgTypes[idx].namespaceName,\n                      outputArgTypes[idx].name\n                    )\n              } as ${sql.identifier(\n                // According to https://www.postgresql.org/docs/10/static/sql-createfunction.html,\n                // \"If you omit the name for an output argument, the system will choose a default column name.\"\n                // In PG 9.x and 10, the column names appear to be assigned with a `column` prefix.\n                outputArgName !== \"\" ? outputArgName : `column${idx + 1}`\n              )}`\n          ),\n          \", \"\n        )}\nfrom (values ${sql.join(\n          values.map(value => sql.query`(${sql.value(value)}::text[])`),\n          \", \"\n        )}) as ${sqlValuesAlias}(output_value_list)`\n      : sql.query`\\\nselect str::${sqlTypeIdentifier} as ${sqlResultSourceAlias}\nfrom unnest((${sql.value(values)})::text[]) str`;\n    const { rows: filteredValuesResults } =\n      values.length > 0\n        ? await performQuery(\n            pgClient,\n            sql.query`with ${sqlResultSourceAlias} as (${convertFieldBack}) ${sqlResultQuery}`\n          )\n        : { rows: [] };\n    const finalRows = rawValues.map(rawValue =>\n      /*\n       * We can't simply return 'null' here because this is expected to have\n       * come from PG, and that would never return 'null' for a row - only\n       * the fields within said row. Using `__isNull` here is a simple\n       * workaround to this, that's caught by `pg2gql`.\n       */\n      rawValue === null ? { __isNull: true } : filteredValuesResults.shift()\n    );\n    return finalRows;\n  }\n}\n"],"mappings":"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"}