{"version":3,"file":"PgRowByUniqueConstraint.js","names":["_debugSql","_interopRequireDefault","require","obj","__esModule","default","PgRowByUniqueConstraint","builder","subscriptions","hook","fields","build","context","extend","parseResolveInfo","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","gql2pg","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","graphql","GraphQLNonNull","inflection","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","pgPrepareAndRun","scope","isRootQuery","fieldWithHooks","class","reduce","memo","table","namespace","TableType","type","id","sqlFullTableName","identifier","name","uniqueConstraints","constraints","filter","con","forEach","constraint","keys","keyAttributes","some","key","every","_","Error","fieldName","rowByUniqueKeys","keysIncludingMeta","map","sqlIdentifier","columnName","column","queryFromResolveDataOptions","useAsterisk","queryFromResolveDataCallback","queryBuilder","args","primaryKeyConstraint","selectIdentifiers","sqlTableAlias","getTableAlias","typeModifier","where","fragment","getDataFromParsedResolveInfoFragment","typeId","InputType","resolve","parent","resolveContext","resolveInfo","pgClient","liveRecord","rootValue","parsedResolveInfoFragment","resolveData","query","undefined","text","values","compile","debugSql","enabled","rows","row","__identifiers","isPgRowByUniqueConstraintField","pgFieldIntrospection","exports"],"sources":["../../src/plugins/PgRowByUniqueConstraint.js"],"sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugSql from \"./debugSql\";\n\nexport default (async function PgRowByUniqueConstraint(\n  builder,\n  { subscriptions }\n) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        parseResolveInfo,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        gql2pg,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        graphql: { GraphQLNonNull },\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        pgPrepareAndRun,\n      } = build;\n      const {\n        scope: { isRootQuery },\n        fieldWithHooks,\n      } = context;\n\n      if (!isRootQuery) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        introspectionResultsByKind.class.reduce((memo, table) => {\n          // PERFORMANCE: These used to be .filter(...) calls\n          if (!table.namespace) return memo;\n          if (omit(table, \"read\")) return memo;\n\n          const TableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          const sqlFullTableName = sql.identifier(\n            table.namespace.name,\n            table.name\n          );\n          if (TableType) {\n            const uniqueConstraints = table.constraints.filter(\n              con => con.type === \"u\" || con.type === \"p\"\n            );\n            uniqueConstraints.forEach(constraint => {\n              if (omit(constraint, \"read\")) {\n                return;\n              }\n              const keys = constraint.keyAttributes;\n              if (keys.some(key => omit(key, \"read\"))) {\n                return;\n              }\n              if (!keys.every(_ => _)) {\n                throw new Error(\n                  \"Consistency error: could not find an attribute!\"\n                );\n              }\n              const fieldName = inflection.rowByUniqueKeys(\n                keys,\n                table,\n                constraint\n              );\n              const keysIncludingMeta = keys.map(key => ({\n                ...key,\n                sqlIdentifier: sql.identifier(key.name),\n                columnName: inflection.column(key),\n              }));\n              // Precomputation for performance\n              const queryFromResolveDataOptions = {\n                useAsterisk: false, // Because it's only a single relation, no need\n              };\n              const queryFromResolveDataCallback = (queryBuilder, args) => {\n                if (subscriptions && table.primaryKeyConstraint) {\n                  queryBuilder.selectIdentifiers(table);\n                }\n                const sqlTableAlias = queryBuilder.getTableAlias();\n                keysIncludingMeta.forEach(\n                  ({ sqlIdentifier, columnName, type, typeModifier }) => {\n                    queryBuilder.where(\n                      sql.fragment`${sqlTableAlias}.${sqlIdentifier} = ${gql2pg(\n                        args[columnName],\n                        type,\n                        typeModifier\n                      )}`\n                    );\n                  }\n                );\n              };\n\n              memo[fieldName] = fieldWithHooks(\n                fieldName,\n                ({ getDataFromParsedResolveInfoFragment }) => {\n                  return {\n                    type: TableType,\n                    args: keysIncludingMeta.reduce(\n                      (memo, { typeId, typeModifier, columnName, name }) => {\n                        const InputType = pgGetGqlInputTypeByTypeIdAndModifier(\n                          typeId,\n                          typeModifier\n                        );\n                        if (!InputType) {\n                          throw new Error(\n                            `Could not find input type for key '${name}' on type '${TableType.name}'`\n                          );\n                        }\n                        memo[columnName] = {\n                          type: new GraphQLNonNull(InputType),\n                        };\n                        return memo;\n                      },\n                      {}\n                    ),\n                    async resolve(parent, args, resolveContext, resolveInfo) {\n                      const { pgClient } = resolveContext;\n                      const liveRecord =\n                        resolveInfo.rootValue &&\n                        resolveInfo.rootValue.liveRecord;\n                      const parsedResolveInfoFragment =\n                        parseResolveInfo(resolveInfo);\n                      parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n                      const resolveData = getDataFromParsedResolveInfoFragment(\n                        parsedResolveInfoFragment,\n                        TableType\n                      );\n                      const query = queryFromResolveData(\n                        sqlFullTableName,\n                        undefined,\n                        resolveData,\n                        queryFromResolveDataOptions,\n                        queryBuilder =>\n                          queryFromResolveDataCallback(queryBuilder, args),\n                        resolveContext,\n                        resolveInfo.rootValue\n                      );\n                      const { text, values } = sql.compile(query);\n                      if (debugSql.enabled) debugSql(text);\n                      const {\n                        rows: [row],\n                      } = await pgPrepareAndRun(pgClient, text, values);\n                      if (subscriptions && liveRecord && row) {\n                        liveRecord(\"pg\", table, row.__identifiers);\n                      }\n                      return row;\n                    },\n                  };\n                },\n                {\n                  isPgRowByUniqueConstraintField: true,\n                  pgFieldIntrospection: constraint,\n                }\n              );\n            });\n          }\n          return memo;\n        }, {}),\n        `Adding \"row by unique constraint\" fields to root Query type`\n      );\n    },\n    [\"PgRowByUniqueConstraint\"]\n  );\n}: Plugin);\n"],"mappings":"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"}