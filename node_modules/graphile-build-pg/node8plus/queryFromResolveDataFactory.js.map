{"version":3,"file":"queryFromResolveDataFactory.js","names":["_QueryBuilder","_interopRequireDefault","require","sql","_interopRequireWildcard","_isSafeInteger","_assert","_util","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","identity","_","undefined","assertSafeName","name","Error","inspect","test","_default","queryBuilderOptions","from","fromAlias","resolveData","inOptions","withBuilder","context","rootValue","pgQuery","pgAggregateQuery","pgNamedQueryContainer","pgNamedQuery","pgCursorPrefix","reallyRawCursorPrefix","pgDontUseAsterisk","calculateHasNextPage","calculateHasPreviousPage","usesCursor","explicitlyUsesCursor","length","push","query","queryBuilder","options","innerQueryBuilder","fragment","build","onlyJsonField","getTableExpression","getTableAlias","buildWhereClause","forEach","preventAsterisk","useAsterisk","rawCursorPrefix","filter","QueryBuilder","i","l","generateNextPrevPageSql","sqlQueryAlias","canHaveCursorInWhere","queryHasBefore","queryHasFirst","offset","invert","sqlCommonUnbounded","sqlCommon","isForwardOrSymmetric","assert","literal","buildWhereBoundClause","getSelectCursor","blank","value","limit","getFinalLimitAndOffset","getPgCursorPrefix","data","cursorPrefix","map","val","withPagination","withPaginationAsFields","withCursor","selectCursor","orderBy","getOrderByExpressionsAndDirections","expr","isOrderUnique","join","getFinalOffset","setCursorComparator","cursorValue","isAfter","badCursor","whereBound","orderByExpressionsAndDirections","rawPrefixes","slice","rawCursors","Array","isArray","sqlFilter","sqlCursors","sqlExpression","ascending","comparison","Number","sqlOldFilter","null","isSafeInteger","cursorValue1","getOffset","Math","max","haveFields","getSelectFieldsCount","identifier","Symbol","sqlSummaryAlias","compiledData","upper","queryHasAfter","lower","queryHasZeroLimit","getFinalLimit","first","queryHasLast","last","hasNextPage","hasPreviousPage","sqlWith","sqlFrom","fields","groups","keys","groupName","queryCallbacks","containers","c","container","aggregatesSql","alias","jsonbBuildObject","exports"],"sources":["../src/queryFromResolveDataFactory.js"],"sourcesContent":["// @flow\nimport QueryBuilder from \"./QueryBuilder\";\nimport type { QueryBuilderOptions } from \"./QueryBuilder\";\nimport type { RawAlias } from \"./QueryBuilder\";\nimport * as sql from \"pg-sql2\";\nimport type { SQL } from \"pg-sql2\";\nimport type { DataForType } from \"graphile-build\";\nimport isSafeInteger from \"lodash/isSafeInteger\";\nimport assert from \"assert\";\nimport { inspect } from \"util\";\n\n// eslint-disable-next-line flowtype/no-weak-types\ntype GraphQLContext = any;\n\nconst identity = _ => _ !== null && _ !== undefined;\n\nfunction assertSafeName(name: mixed) {\n  if (typeof name !== \"string\") {\n    throw new Error(\n      `Expected name to be a string; instead received '${inspect(name)}'`\n    );\n  }\n  if (!/^[@a-zA-Z0-9_]{1,63}$/.test(name)) {\n    throw new Error(\n      `Name '${name}' is not safe - either it is too long, too short, or has invalid characters`\n    );\n  }\n}\n\nexport default (queryBuilderOptions: QueryBuilderOptions = {}) =>\n  (\n    from: SQL,\n    fromAlias: ?SQL,\n    resolveData: DataForType,\n    inOptions: {\n      withPagination?: boolean,\n      withPaginationAsFields?: boolean,\n      asJson?: boolean,\n      asJsonAggregate?: boolean,\n      addNullCase?: boolean,\n      addNotDistinctFromNullCase?: boolean,\n      onlyJsonField?: boolean,\n      useAsterisk?: boolean,\n      withCursor?: boolean,\n    },\n    // TODO:v5: context is not optional\n    withBuilder?: ((builder: QueryBuilder) => void) | null | void,\n    context?: GraphQLContext = {},\n    rootValue?: any // eslint-disable-line flowtype/no-weak-types\n  ) => {\n    const {\n      pgQuery,\n      pgAggregateQuery, // Shorthand for using pgNamedQueryContainer/pgNamedQuery combo\n      pgNamedQueryContainer = [],\n      pgNamedQuery = [],\n      pgCursorPrefix: reallyRawCursorPrefix,\n      pgDontUseAsterisk,\n      calculateHasNextPage,\n      calculateHasPreviousPage,\n      usesCursor: explicitlyUsesCursor,\n    } = resolveData;\n    // Push a query container for aggregates\n    if ((pgAggregateQuery && pgAggregateQuery.length) || pgNamedQuery.length) {\n      pgNamedQueryContainer.push({\n        name: \"aggregates\",\n        query: ({ queryBuilder, options, innerQueryBuilder }) => sql.fragment`\\\n(\n  select ${innerQueryBuilder.build({ onlyJsonField: true })}\n  from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n  where ${queryBuilder.buildWhereClause(false, false, options)}\n)`,\n      });\n    }\n    // Convert pgAggregateQuery to pgNamedQueryContainer/pgNamedQuery combo\n    if (pgAggregateQuery && pgAggregateQuery.length) {\n      // And a query for each previous query\n      pgAggregateQuery.forEach(query => {\n        pgNamedQuery.push({ name: \"aggregates\", query });\n      });\n    }\n\n    const preventAsterisk = pgDontUseAsterisk\n      ? pgDontUseAsterisk.length > 0\n      : false;\n    const options = {\n      ...inOptions,\n      // Allow pgDontUseAsterisk to override useAsterisk\n      useAsterisk: inOptions.useAsterisk && !preventAsterisk,\n    };\n\n    const usesCursor: boolean =\n      (explicitlyUsesCursor && explicitlyUsesCursor.length > 0) ||\n      (calculateHasNextPage && calculateHasNextPage.length > 0) ||\n      (calculateHasPreviousPage && calculateHasPreviousPage.length > 0) ||\n      false;\n    const rawCursorPrefix =\n      reallyRawCursorPrefix && reallyRawCursorPrefix.filter(identity);\n\n    const queryBuilder = new QueryBuilder(\n      queryBuilderOptions,\n      context,\n      rootValue\n    );\n    queryBuilder.from(from, fromAlias ? fromAlias : undefined);\n\n    if (withBuilder) {\n      withBuilder(queryBuilder);\n    }\n    if (pgQuery) {\n      for (let i = 0, l = pgQuery.length; i < l; i++) {\n        pgQuery[i](queryBuilder, resolveData);\n      }\n    }\n\n    function generateNextPrevPageSql(\n      sqlQueryAlias,\n      canHaveCursorInWhere,\n      queryHasBefore,\n      queryHasFirst,\n      offset = 0,\n      invert = false\n    ) {\n      /*\n       * Strap in, 'coz this function gets hairy!\n       *\n       * The point of this function is to return SQL which will resolve to a\n       * boolean true/false depending on whether or not there is a (invert ?\n       * \"previous\" : \"next\") page.\n       *\n       * Connections have before, after, first, last and offset.\n       * - Users are forbidden from setting both first and last.\n       * - Users are forbidden from setting both offset and last.\n       *\n       * Further there are two main modes of paginating, one works by adding a\n       * where clause (this is preferred, but is not always possible, and is\n       * indicated by `canHaveCursorInWhere === true`) and the other works using\n       * standard LIMIT/OFFSET SQL pagination (and is indicated by\n       * `canHaveCursorInWhere === false`).\n       *\n       * The following diagram shows a full collection of records, #, starting at\n       * START and ending at END. The key after, before, offset, first and last\n       * variables are shown. One thing not show is that it's possible to have\n       * fewer records between before and after than requested by first or last.\n       * Another detail not clearly show is that if there is no `after` then\n       * `START` is used, similarly if there is no `before` then `END` is used.\n       *\n       *   #################################################### < collection\n       *   ^      ^<-offset->^<-first->^      ^<-last->^      ^\n       *   |      |          |         |      |        |      |\n       *   |      |          +---------+      +--------+      |\n       *   |      |          |  DATA1           DATA2  |      |\n       *   |      |          |                         |      |\n       *   |      |          |                         |      |\n       *   |      |          +-------------------------+      |\n       *   |      |                     DATA3          |      |\n       *   |    after                                before   |\n       *   |                                                  |\n       * START                                               END\n       *\n       * We want one of the three DATA blocks:\n       *\n       * - If `first` is set, then we want DATA1.\n       * - If `last` is set then we want DATA2.\n       * - If neither is set then we want DATA3.\n       *\n       * (Remember: you cannot set both `first` and `last` at the same time.)\n       *\n       * When invert === false:\n       *\n       *   Note that both DATA2 and DATA3 end at the same point, and we only care\n       *   if there's data *after* the relevant DATA block, so really we only\n       *   care if the query specified `first` (`queryHasFirst`) which makes\n       *   things complex (ending at the end of DATA1), otherwise we can use\n       *   `before` as the bound (end of DATA2/DATA3).\n       *\n       * When invert === true:\n       *\n       *   Similarly, DATA1 and DATA3 start at the same point, and we're going\n       *   backwards so we only care if there's data *before* the DATA block, so\n       *   really we just need to know if the query set `last` or not, but since\n       *   this is inverted we call it `queryHasFirst`.\n       *\n       * When `invert` is false we're calculating `hasNextPage`, when true we're\n       * calculating `hasPreviousPage`.\n       *\n       * Because of the near-symmetry of requesting hasPreviousPage vs\n       * hasNextPage we always pretend we're determining `hasNextPage`, and we\n       * just invert everything.\n       */\n\n      const sqlCommonUnbounded = sql.fragment`\\\nselect 1\nfrom ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}`;\n      /*\n       * This variable is a fragment to go into an `EXISTS(...)` call (after some tweaks).\n       *\n       * The buildWhereClause takes three arguments:\n       *\n       * - includeLowerBound (we want this for hasNextPage but not hasPreviousPage)\n       * - includeUpperBound (we want this for hasPreviousPage but not hasNextPage)\n       * - options (specifically `{addNullCase, addNotDistinctFromNullCase}`) -\n       *   we just pass this through.\n       *\n       * So in hasNextPage mode (invert === false), this common SQL ends up\n       * representing the collection from `(after || START)` onwards with no\n       * upper bound. In hasPreviousPage mode (invert === true), it represents\n       * everything from `(before || END)` backwards, with no lower bound.\n       */\n      const sqlCommon = sql.fragment`\\\n${sqlCommonUnbounded}\nwhere ${queryBuilder.buildWhereClause(!invert, invert, options)}`;\n\n      /*\n       * Since the offset makes the diagram asymmetric, if offset === 0\n       * then the diagram is symmetric and things are simplified a little.\n       */\n      const isForwardOrSymmetric = !invert || offset === 0;\n\n      if (!isForwardOrSymmetric) {\n        assert(invert);\n        assert(offset > 0);\n        // We're looking for a previous page, and there's an offset, so lets just\n        // assume there's a previous page where offset is smaller.\n        return sql.literal(true);\n      } else if (canHaveCursorInWhere) {\n        assert(isForwardOrSymmetric);\n        if (!queryHasBefore && !queryHasFirst) {\n          assert(isForwardOrSymmetric);\n          // There can be no next page since there's no upper bound\n          return sql.literal(false);\n        } else if (queryHasBefore && !queryHasFirst) {\n          /*\n           * We invert the upper buildWhereBoundClause to only represent the data\n           * after `before`, then check if there's at least one record in that set.\n           *\n           * This only works if the `before` cursor can be represented in the\n           * SQL WHERE clause, otherwise we're doing limit/offset pagination\n           * which requires different logic. It also only works if there's no\n           * `first` clause, otherwise there could be a next page before the\n           * `before` clause.\n           */\n          return sql.fragment`\\\nexists(\n  ${sqlCommonUnbounded}\n  where ${queryBuilder.buildWhereClause(false, false, options)}\n  and not (${queryBuilder.buildWhereBoundClause(invert)})\n)`;\n        } else {\n          assert(queryHasFirst);\n          // queryHasBefore could be true or false.\n          /*\n           * There's a few ways that we could determine if there's a next page.\n           *\n           * If !queryHasBefore, we could COUNT(*) the number of rows in\n           * `sqlCommon` and see if it's larger than `first`:\n           * `(select count(*) > ${first} from (${sqlCommon}) __random_table_alias__)`\n           *\n           * If !queryHasBefore, we could build a subquery table of offsetData\n           * from sqlCommon and see if it contains any rows:\n           * `EXISTS(select 1 from (${sqlCommon} OFFSET ${first}) __random_table_alias__)`.\n           *\n           * We could see if there's at least one row in sqlCommon that's not\n           * already in our chosen result set.\n           *\n           * We've chosen the latter approach here because it doesn't place a limit\n           * on queryHasBefore.\n           */\n          // Drop the `first` limit, see if there are any records that aren't\n          // already in the list we've fetched.\n          return sql.fragment`\\\nexists(\n  ${sqlCommon}\n  and (${queryBuilder.getSelectCursor()})::text not in (select __cursor::text from ${sqlQueryAlias})\n  ${offset === 0 ? sql.blank : sql.fragment`offset ${sql.value(offset)}`}\n)`;\n        }\n      } else {\n        assert(!invert || offset === 0); // isForwardOrSymmetric\n        assert(!canHaveCursorInWhere);\n        // We're dealing with LIMIT/OFFSET pagination here, which means `natural`\n        // cursors, so the `queryBuilder` factors the before/after, first/last\n        // into the limit / offset.\n        const { limit } = queryBuilder.getFinalLimitAndOffset();\n\n        if (limit == null) {\n          // If paginating backwards, then offset > 0 has already been dealt\n          // with. Unbounded, so there's no next page.\n          return sql.fragment`false`;\n        } else if (invert) {\n          assert(offset === 0);\n          // Paginating backwards and there's no offset (which factors in before/after), so there's no previous page.\n          return sql.fragment`false`;\n        } else {\n          assert(!invert);\n          /*\n           * We're paginating forwards; either there's a before, there's a first,\n           * or both.\n           *\n           * We want to see if there's more than limit+offset records in sqlCommon.\n           */\n          return sql.fragment`\\\nexists(\n  ${sqlCommon}\n  offset ${sql.literal(limit + offset)}\n)`;\n        }\n      }\n    }\n    const getPgCursorPrefix = () =>\n      rawCursorPrefix && rawCursorPrefix.length > 0\n        ? rawCursorPrefix\n        : queryBuilder.data.cursorPrefix.map(val => sql.literal(val));\n    if (\n      options.withPagination ||\n      options.withPaginationAsFields ||\n      options.withCursor\n    ) {\n      // Sometimes we need a __cursor even if it's not a collection; e.g. to get the edge field on a mutation\n      if (usesCursor) {\n        queryBuilder.selectCursor((): SQL => {\n          const orderBy = queryBuilder\n            .getOrderByExpressionsAndDirections()\n            .map(([expr]) => expr);\n          if (queryBuilder.isOrderUnique() && orderBy.length > 0) {\n            return sql.fragment`json_build_array(${sql.join(\n              [\n                ...getPgCursorPrefix(),\n                sql.fragment`json_build_array(${sql.join(orderBy, \", \")})`,\n              ],\n              \", \"\n            )})`;\n          } else {\n            return sql.fragment`json_build_array(${sql.join(\n              getPgCursorPrefix(),\n              \", \"\n            )}, ${\n              /*\n               * NOTE[useAsterisk/row_number]: If we have useAsterisk then the\n               * query with limit offset is in a subquery, so our row_number()\n               * call doesn't know about it. Here we add the offset back in\n               * again. See matching NOTE in QueryBuilder.js.\n               */\n              options.useAsterisk\n                ? sql.fragment`${sql.literal(\n                    queryBuilder.getFinalOffset() || 0\n                  )} + `\n                : sql.fragment``\n            }(row_number() over (partition by 1)))`;\n          }\n        });\n      }\n    }\n    if (options.withPagination || options.withPaginationAsFields) {\n      queryBuilder.setCursorComparator((cursorValue, isAfter) => {\n        function badCursor() {\n          queryBuilder.whereBound(sql.fragment`false`, isAfter);\n        }\n        const orderByExpressionsAndDirections =\n          queryBuilder.getOrderByExpressionsAndDirections();\n        if (orderByExpressionsAndDirections.length > 0) {\n          if (!queryBuilder.isOrderUnique()) {\n            throw new Error(\n              \"The order supplied is not unique, so before/after cursors cannot be used. Please ensure the supplied order includes all the columns from the primary key or a unique constraint.\"\n            );\n          }\n          const rawPrefixes = cursorValue.slice(0, cursorValue.length - 1);\n          const rawCursors = cursorValue[cursorValue.length - 1];\n          if (rawPrefixes.length !== getPgCursorPrefix().length) {\n            badCursor();\n            return;\n          }\n          if (!Array.isArray(rawCursors)) {\n            badCursor();\n            return;\n          }\n          let sqlFilter = sql.fragment`false`;\n          const sqlCursors = rawCursors.map(val => sql.value(val));\n          for (\n            let i = orderByExpressionsAndDirections.length - 1;\n            i >= 0;\n            i--\n          ) {\n            const [sqlExpression, ascending] =\n              orderByExpressionsAndDirections[i];\n            // If ascending and isAfter then >\n            // If ascending and isBefore then <\n            const comparison =\n              Number(ascending) ^ Number(!isAfter)\n                ? sql.fragment`>`\n                : sql.fragment`<`;\n\n            const sqlOldFilter = sqlFilter;\n            sqlFilter = sql.fragment`\\\n(\\\n  (${sqlExpression} ${comparison} ${sqlCursors[i] || sql.null})\nOR\\\n  (\\\n    ${sqlExpression} = ${sqlCursors[i] || sql.null}\\\n  AND\\\n    ${sqlOldFilter}\\\n  )\\\n)`;\n          }\n\n          // Check the cursor prefixes apply\n          // TODO:v5: we should be able to do this in JS-land rather than SQL-land\n          sqlFilter = sql.fragment`(((${sql.join(\n            getPgCursorPrefix(),\n            \", \"\n          )}) = (${sql.join(\n            rawPrefixes.map(val => sql.value(val)),\n            \", \"\n          )})) AND (${sqlFilter}))`;\n          queryBuilder.whereBound(sqlFilter, isAfter);\n        } else if (\n          cursorValue[0] === \"natural\" &&\n          isSafeInteger(cursorValue[1]) &&\n          // $FlowFixMe: we know this is a number\n          cursorValue[1] >= 0\n        ) {\n          // $FlowFixMe: we know this is a number\n          const cursorValue1: number = cursorValue[1];\n          if (isAfter) {\n            queryBuilder.offset(() => cursorValue1);\n          } else {\n            queryBuilder.limit(() => {\n              const offset = queryBuilder.getOffset();\n              return Math.max(0, cursorValue1 - offset - 1);\n            });\n          }\n        } else {\n          throw new Error(\n            \"Cannot use 'before'/'after' without unique 'orderBy'\"\n          );\n        }\n      });\n\n      const query = queryBuilder.build(options);\n      const haveFields = queryBuilder.getSelectFieldsCount() > 0;\n      const sqlQueryAlias = sql.identifier(Symbol());\n      const sqlSummaryAlias = sql.identifier(Symbol());\n      //\n      // Tables should ALWAYS push their PK onto the order stack, if this isn't\n      // present then we're either dealing with a view or a table without a PK.\n      // Either way, we don't have anything to guarantee uniqueness so we need to\n      // fall back to limit/offset.\n      //\n      // TODO: support unique keys in PgAllRows etc\n      // TODO: add a warning for cursor-based pagination when using the fallback\n      // TODO: if it is a view maybe add a warning encouraging pgViewUniqueKey\n      const canHaveCursorInWhere =\n        queryBuilder.getOrderByExpressionsAndDirections().length > 0 &&\n        queryBuilder.isOrderUnique();\n      const queryHasBefore =\n        queryBuilder.compiledData.whereBound.upper.length > 0;\n      const queryHasAfter =\n        queryBuilder.compiledData.whereBound.lower.length > 0;\n      const queryHasZeroLimit = queryBuilder.getFinalLimit() === 0;\n      const queryHasFirst = isSafeInteger(queryBuilder.compiledData.first);\n      const queryHasLast = isSafeInteger(queryBuilder.compiledData.last);\n      const hasNextPage = queryHasZeroLimit\n        ? sql.literal(false)\n        : generateNextPrevPageSql(\n            sqlQueryAlias,\n            canHaveCursorInWhere,\n            queryHasBefore,\n            queryHasFirst,\n            queryBuilder.getFinalOffset() || 0\n          );\n      const hasPreviousPage = queryHasZeroLimit\n        ? sql.literal(false)\n        : generateNextPrevPageSql(\n            sqlQueryAlias,\n            canHaveCursorInWhere,\n            queryHasAfter,\n            queryHasLast,\n            queryBuilder.getFinalOffset() || 0,\n            true\n          );\n\n      const sqlWith = haveFields\n        ? sql.fragment`with ${sqlQueryAlias} as (${query}), ${sqlSummaryAlias} as (select json_agg(to_json(${sqlQueryAlias})) as data from ${sqlQueryAlias})`\n        : sql.fragment``;\n      const sqlFrom = sql.fragment``;\n      const fields: Array<[SQL, RawAlias]> = [];\n      if (haveFields) {\n        fields.push([\n          sql.fragment`coalesce((select ${sqlSummaryAlias}.data from ${sqlSummaryAlias}), '[]'::json)`,\n          \"data\",\n        ]);\n        if (calculateHasNextPage) {\n          fields.push([hasNextPage, \"hasNextPage\"]);\n        }\n        if (calculateHasPreviousPage) {\n          fields.push([hasPreviousPage, \"hasPreviousPage\"]);\n        }\n      }\n      if (pgNamedQuery && pgNamedQuery.length) {\n        const groups = {};\n        pgNamedQuery.forEach(({ name, query }) => {\n          assertSafeName(name);\n          if (!groups[name]) {\n            groups[name] = [];\n          }\n          groups[name].push(query);\n        });\n        Object.keys(groups).forEach(groupName => {\n          const queryCallbacks = groups[groupName];\n\n          // Get container\n          const containers = pgNamedQueryContainer.filter(\n            c => c.name === groupName\n          );\n          if (containers.length === 0) {\n            throw new Error(\n              `${queryCallbacks.length} pgNamedQuery entries with name: '${groupName}' existed, but there was no matching pgNamedQueryContainer.`\n            );\n          }\n          if (containers.length > 1) {\n            throw new Error(\n              `${containers.length} pgNamedQueryContainer entries with name: '${groupName}' existed, but there should be exactly one.`\n            );\n          }\n          const container = containers[0];\n\n          const innerQueryBuilder = new QueryBuilder(\n            queryBuilderOptions,\n            context,\n            rootValue\n          );\n          innerQueryBuilder.from(\n            queryBuilder.getTableExpression(),\n            queryBuilder.getTableAlias()\n          );\n\n          for (let i = 0, l = queryCallbacks.length; i < l; i++) {\n            queryCallbacks[i](innerQueryBuilder);\n          }\n\n          // Generate the SQL statement (e.g. `select ${innerQueryBuilder.build({onlyJsonField: true})} from ${queryBuilder.getTableExpression()} as ...`)\n          const aggregatesSql = container.query({\n            queryBuilder,\n            innerQueryBuilder,\n            options,\n          });\n\n          fields.push([aggregatesSql, groupName]);\n        });\n      }\n      if (options.withPaginationAsFields) {\n        return sql.fragment`${sqlWith} select ${sql.join(\n          fields.map(\n            ([expr, alias]) => sql.fragment`${expr} as ${sql.identifier(alias)}`\n          ),\n          \", \"\n        )} ${sqlFrom}`;\n      } else {\n        return sql.fragment`${sqlWith} select ${queryBuilder.jsonbBuildObject(\n          fields\n        )} ${sqlFrom}`;\n      }\n    } else {\n      const query = queryBuilder.build(options);\n      return query;\n    }\n  };\n"],"mappings":"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"}