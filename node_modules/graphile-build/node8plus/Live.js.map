{"version":3,"file":"Live.js","names":["_callbackToAsyncIterator","_interopRequireDefault","require","_lodash","obj","__esModule","default","DEBOUNCE_DURATION","MONITOR_THROTTLE_DURATION","Math","max","parseInt","process","env","LIVE_THROTTLE","LiveSource","subscribeCollection","_callback","_collectionIdentifier","_predicate","subscribeRecord","_recordIdentifier","exports","LiveProvider","constructor","namespace","sources","registerSource","source","push","collectionIdentifierIsValid","recordIdentifierIsValid","LiveMonitor","providers","extraRootValue","released","subscriptionReleasersByCounter","changeCallback","changeCounter","liveConditionsByCounter","handleChange","_reallyHandleChange","cb","counter","String","changeRootValue","liveCollection","bind","liveRecord","liveConditions","release","resetBefore","console","warn","onChange","callback","Error","setImmediate","throttle","leading","trailing","currentCounter","oldCounters","Object","keys","filter","n","oldCounter","releaser","cancel","Infinity","collectionIdentifier","predicate","provider","length","recordIdentifier","LiveCoordinator","subscribe","registerProvider","getMonitor","_parent","_args","_context","_info","monitor","liveAbort","e","iterator","throw","makeAsyncIteratorFromMonitor","callbackToAsyncIterator","onClose"],"sources":["../src/Live.js"],"sourcesContent":["// @flow\n/* eslint-disable flowtype/no-weak-types */\nimport callbackToAsyncIterator from \"./callbackToAsyncIterator\";\nimport type { GraphQLResolveInfo } from \"graphql\";\nimport { throttle } from \"lodash\";\n\ntype SubscriptionReleaser = () => void;\ntype SubscriptionCallback = () => void;\n\ntype Predicate = (record: any) => boolean;\ntype PredicateGenerator = (data: any) => Predicate;\n\nconst DEBOUNCE_DURATION = 25;\n\nconst MONITOR_THROTTLE_DURATION = Math.max(\n  DEBOUNCE_DURATION + 1,\n  parseInt(process.env.LIVE_THROTTLE || \"\", 10) || 500\n);\n\n/*\n * Sources are long-lived (i.e. in \"watch\" mode you just re-use the same one\n * over and over) because there is no release for them\n */\nexport class LiveSource {\n  subscribeCollection(\n    _callback: SubscriptionCallback,\n    _collectionIdentifier: any,\n    _predicate?: Predicate\n  ): SubscriptionReleaser | null {\n    return null;\n  }\n\n  subscribeRecord(\n    _callback: SubscriptionCallback,\n    _collectionIdentifier: any,\n    _recordIdentifier: any\n  ): SubscriptionReleaser | null {\n    return null;\n  }\n}\n\n/*\n * Providers enable a namespace, perform validation, and track the sources used\n * by that namespace within one single schema build. The should not directly use\n * any long-lived features as they do not have an explicit \"release\"/\"close\"\n * command when a new schema is built.\n */\nexport class LiveProvider {\n  sources: Array<LiveSource>;\n  namespace: string;\n\n  constructor(namespace: string) {\n    this.namespace = namespace;\n    this.sources = [];\n  }\n\n  registerSource(source: LiveSource) {\n    this.sources.push(source);\n  }\n\n  collectionIdentifierIsValid(_collectionIdentifier: any): boolean {\n    return false;\n  }\n\n  recordIdentifierIsValid(\n    _collectionIdentifier: any,\n    _recordIdentifier: any\n  ): boolean {\n    return false;\n  }\n}\n\n/*\n * During a single execution of GraphQL (specifically a subscription request),\n * the LiveMonitor tracks the resources viewed and subscribes to updates in them.\n */\nexport class LiveMonitor {\n  released: boolean;\n  providers: { [namespace: string]: LiveProvider };\n  subscriptionReleasersByCounter: {\n    [counter: string]: (() => void)[],\n  };\n  liveConditionsByCounter: { [counter: string]: Array<PredicateGenerator> };\n  changeCallback: ((arg: any) => void) | null;\n  changeCounter: number;\n  extraRootValue: any;\n\n  handleChange: (() => void) | null;\n  _reallyHandleChange: (() => void) | null;\n  onChange: (callback: () => void) => () => void;\n\n  constructor(\n    providers: { [namespace: string]: LiveProvider },\n    extraRootValue: any\n  ) {\n    this.extraRootValue = extraRootValue;\n    this.released = false;\n    this.providers = providers;\n    this.subscriptionReleasersByCounter = {};\n    this.changeCallback = null;\n    this.changeCounter = 0;\n    this.liveConditionsByCounter = {};\n    this.handleChange = function () {\n      /* This function is throttled to ~25ms (see constructor); it's purpose is\n       * to bundle up all the changes that occur in a small window into the same\n       * handle change flow, so _reallyHandleChange doesn't get called twice in\n       * quick succession. _reallyHandleChange is then further throttled with a\n       * larger window, BUT it triggers on both leading and trailing edge,\n       * whereas this only triggers on the trailing edge.\n       */\n      if (this._reallyHandleChange) {\n        this._reallyHandleChange();\n      }\n    };\n\n    this._reallyHandleChange = function () {\n      // This function is throttled to MONITOR_THROTTLE_DURATION (see constructor)\n      if (this.changeCallback) {\n        // Convince Flow this won't suddenly become null\n        const cb = this.changeCallback;\n        const counter = this.changeCounter++;\n        /*\n         * In live queries we need to know when the current result set has\n         * finished being calculated so that we know we've received all the\n         * liveRecord / liveCollection calls and can release the out of date\n         * ones. To achieve this, we use a custom `subscribe` function which\n         * calls `rootValue.release()` once the result set has been calculated.\n         */\n        this.subscriptionReleasersByCounter[String(counter)] = [];\n        this.liveConditionsByCounter[String(counter)] = [];\n        const changeRootValue = {\n          ...this.extraRootValue,\n          counter,\n          liveCollection: this.liveCollection.bind(this, counter),\n          liveRecord: this.liveRecord.bind(this, counter),\n          liveConditions: this.liveConditionsByCounter[String(counter)],\n          release: () => {\n            // Despite it's name, this means that the execution has complete, which means we're actually releasing everything *before* this.\n            this.resetBefore(counter);\n          },\n        };\n        cb(changeRootValue);\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(\"Change occurred, but no-one was listening\");\n      }\n    };\n\n    this.onChange = function (callback: () => void) {\n      if (this.released) {\n        throw new Error(\"Monitors cannot be reused.\");\n      }\n      if (this.changeCallback) {\n        throw new Error(\"Already monitoring for changes\");\n      }\n      // Throttle to every 250ms\n      this.changeCallback = callback;\n      if (this.handleChange) {\n        setImmediate(this.handleChange);\n      }\n      return () => {\n        if (this.changeCallback === callback) {\n          this.changeCallback = null;\n        }\n        this.release();\n      };\n    };\n\n    this.handleChange = throttle(\n      this.handleChange.bind(this),\n      DEBOUNCE_DURATION,\n      {\n        leading: false,\n        trailing: true,\n      }\n    );\n    if (!this._reallyHandleChange) {\n      throw new Error(\"This is just to make flow happy\");\n    }\n    this._reallyHandleChange = throttle(\n      this._reallyHandleChange.bind(this),\n      MONITOR_THROTTLE_DURATION - DEBOUNCE_DURATION,\n      {\n        leading: true,\n        trailing: true,\n      }\n    );\n    this.onChange = this.onChange.bind(this);\n  }\n\n  resetBefore(currentCounter: number) {\n    // Clear out of date subscriptionReleasers\n    {\n      const oldCounters = Object.keys(\n        this.subscriptionReleasersByCounter\n      ).filter(n => parseInt(n, 10) < currentCounter);\n      for (const oldCounter of oldCounters) {\n        for (const releaser of this.subscriptionReleasersByCounter[\n          oldCounter\n        ]) {\n          releaser();\n        }\n        delete this.subscriptionReleasersByCounter[oldCounter];\n      }\n    }\n    // Clear out of date liveConditions\n    {\n      const oldCounters = Object.keys(this.liveConditionsByCounter).filter(\n        n => parseInt(n, 10) < currentCounter\n      );\n      for (const oldCounter of oldCounters) {\n        delete this.liveConditionsByCounter[oldCounter];\n      }\n    }\n  }\n\n  release() {\n    if (this.handleChange) {\n      // $FlowFixMe: throttled function\n      this.handleChange.cancel();\n    }\n    this.handleChange = null;\n    if (this._reallyHandleChange) {\n      // $FlowFixMe: throttled function\n      this._reallyHandleChange.cancel();\n    }\n    this._reallyHandleChange = null;\n    this.resetBefore(Infinity);\n    this.providers = {};\n    this.released = true;\n  }\n\n  liveCollection(\n    counter: number,\n    namespace: string,\n    collectionIdentifier: any,\n    predicate: (record: any) => boolean = () => true\n  ) {\n    const handleChange = this.handleChange;\n    if (this.released || !handleChange) {\n      return;\n    }\n    const provider = this.providers[namespace];\n    if (!provider || provider.sources.length === 0) return;\n    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {\n      throw new Error(\n        `Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    for (const source of provider.sources) {\n      const releaser = source.subscribeCollection(\n        handleChange,\n        collectionIdentifier,\n        predicate\n      );\n      if (releaser) {\n        this.subscriptionReleasersByCounter[String(counter)].push(releaser);\n      }\n    }\n  }\n\n  liveRecord(\n    counter: number,\n    namespace: string,\n    collectionIdentifier: any,\n    recordIdentifier: any\n  ) {\n    const handleChange = this.handleChange;\n    if (this.released || !handleChange) {\n      return;\n    }\n    // TODO: if (recordIdentifier == null) {return}\n    const provider = this.providers[namespace];\n    if (!provider || provider.sources.length === 0) return;\n    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {\n      throw new Error(\n        `Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    if (\n      !provider.recordIdentifierIsValid(collectionIdentifier, recordIdentifier)\n    ) {\n      throw new Error(\n        `Invalid record identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    for (const source of provider.sources) {\n      const releaser = source.subscribeRecord(\n        handleChange,\n        collectionIdentifier,\n        recordIdentifier\n      );\n      if (releaser) {\n        this.subscriptionReleasersByCounter[String(counter)].push(releaser);\n      }\n    }\n  }\n}\n\n/*\n * There is one coordinator for each build of the GraphQL schema, it tracks the providers\n * and gives a handy `subscribe` method that can be used for live queries (assuming\n * that the `resolve` is provided the same as in a Query).\n */\nexport class LiveCoordinator {\n  providers: { [namespace: string]: LiveProvider };\n\n  constructor() {\n    this.providers = {};\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  registerProvider(provider: LiveProvider) {\n    const { namespace } = provider;\n    if (this.providers[namespace]) {\n      throw new Error(`Namespace ${namespace} already registered with Live`);\n    }\n    this.providers[namespace] = provider;\n  }\n\n  registerSource(namespace: string, source: LiveSource) {\n    if (!this.providers[namespace]) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `LiveProvider '${namespace}' is not registered, skipping live source.`\n      );\n      return;\n    }\n    this.providers[namespace].registerSource(source);\n  }\n\n  getMonitor(extraRootValue: any) {\n    return new LiveMonitor(this.providers, extraRootValue);\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  subscribe: (\n    _parent: any,\n    _args: any,\n    context: any,\n    _info: GraphQLResolveInfo\n  ) => any;\n  subscribe(\n    _parent: any,\n    _args: any,\n    _context: any,\n    _info: GraphQLResolveInfo\n  ) {\n    const monitor = this.getMonitor({\n      liveAbort: e => {\n        if (iterator) iterator.throw(e);\n      },\n    });\n    const iterator = makeAsyncIteratorFromMonitor(monitor);\n    return iterator;\n  }\n}\n\nexport function makeAsyncIteratorFromMonitor(monitor: LiveMonitor) {\n  return callbackToAsyncIterator(monitor.onChange, {\n    onClose: release => {\n      if (release) release();\n    },\n  });\n}\n"],"mappings":"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"}